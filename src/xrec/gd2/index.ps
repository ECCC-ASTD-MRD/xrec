%!
%%Title: gd 2.0.1
%%Creator: html2ps version 1.0 beta1
%%EndComments
save
2000 dict begin
/d {bind def} bind def
/D {def} d
/t true D
/f false D
/FL [/Times-Roman
/Times-Italic
/Times-Bold
/Times-BoldItalic
/Courier
/Courier-Oblique
/Courier-Bold
/Courier-BoldOblique
/Helvetica
/Helvetica-Oblique
/Helvetica-Bold
/Helvetica-BoldOblique] D
/WF t D
/WI 0 D
/F 0.65 D
/IW 345 F div D
/IL 527 F div D
/PS 791 D
/EF [0 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 2 2] D
/EZ [11 9 19 17 15 13 12 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 8 8] D
/Ey [0 0 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] D
/EG [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1] D
/Tm [1 1 0.8 0.8 0.8 0.8 0.8 0.8 0 0 0 0 0 0 0.5 1 1 1 1 0 0 1.3 0 0] D
/Bm [1 1 0.5 0.5 0.5 0.5 0.5 0.5 0 0 0 0 0 0 0.5 1 1 1 1 0 0 1 0 0] D
/Lm [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 2 0 0 2 0 0 0] D
/Rm [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0] D
/EU [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 0 0] D
/NO t D
/YY [[{()}1][{()}0][{()}2]] D
/ZZ [[{()}1][{()}0][{()}2]] D
/Ts EZ 0 get D
/TU t D
/Xp t D
/AU f D
/SN 0 D
/Cf t D
/Fe t D
/TI 1 Ts mul D
/FE {newpath -14 14 M CP BB 545 14 L 545 -825 L CP BB -14 -825 L closepath} D
/LA {TU PM 0 eq and{IW 28 F div add SA{Sf div}if 0 translate}
 {28 35 translate 90 rotate F SA{Sf mul}if dup scale
 CS CF FS Cf{CA CL get VC}if /Bb f D}ie 0 0 M TF not Tc or
 {Cf{gsave SA{1 Sf div dup scale}if Cb VC FE fill grestore}if Df{Sd}if}if} D
/Pi 0 Ts mul D
/SG [0.8 1 1.53846153846154] D
/Ab 15 D
/J 0 D
/Tc f D
/NH 6 D
/Nf f D
/Pa f D
/LH 1.2 D
/XR f D
/Xr {/pN E D ( [p ) WB pN WB (] )WB} D
/Db [16#FF 16#FF 16#FF] D
/Dt [16#00 16#00 16#00] D
/eA f D
/Lc t D
/Dl [16#00 16#00 16#00] D
/LX f D
/Br 0.25 D
/IA ([IMAGE]) D
/DS {/PF f D()WB NL NP()pop RC ZF} D
/Gb f D
/Mb f D
/Hc [16#00 16#00 16#00] D
/Bl 3 D
/MI -15.2 D
/DX (DRAFT) D
/Di 0 D
/FD 2 D
/Dy 2 D
/cD [16#F0 16#F0 16#F0] D
/FW 0.6 D
/FU [16#00 16#00 16#00] D
/ET {/RM f D /A0 0 D /PN SN D /OU t D /Ou t D /W IW D /LL W D D1
 Ms not TP and{Ip}if /TF f D} D

%-- End of variable part --
/Cd {aload length 2 idiv dup dict begin {D} repeat currentdict end} D
/EX {EC cvx exec} D
/DU {} d
/BB {pop pop}d
/ie {ifelse} d
/E {exch} d
/M {moveto} d
/R {rmoveto} d
/L {lineto} d
/RL {rlineto} d
/CP {currentpoint} d
/SW {stringwidth} d
/GI {getinterval} d
/PI {putinterval} d
/Sg {setgray} d
/LW {setlinewidth} d
/S {dup () ne OU and{0 Co R AT 3 eq LB and HF not and A1 0 ne A2 0 ne or and
 {A2 0 32 A1 0 6 -1 roll awidthshow}{show}ie 0 Co neg R}{pop}ie
 OU PH 3 eq or{/Ms t D}if} D
/U {OU{gsave CP currentfont /FontInfo get /UnderlinePosition get
 0 E currentfont /FontMatrix get dtransform E pop add newpath M dup SW pop
 CJ 0 RL stroke grestore}if} D
/B {OU Br 0 gt and{CP Ts neg Ts .33 mul R gsave 0 Sg
 CP newpath Ts Br mul 0 360 arc closepath UI 2 mod 0 eq{stroke}{fill}ie
 grestore M CP E Ts Br 1 add mul sub E BB /Ms t D}if}D
/NP {Ms TP not or PA and OU and{TP{OR}if f1{mF k2 /mF E D /YC 0 D}if
 TP TU not PM 0 eq or and{showpage}if DU Ip TE not{LA}if 0.6 LW
 /CI 0 D /TP t D /Hs f D /hl 6 D /hL 6 D /HI hi D /Ms f D}if Bs XO BO M} D
/Np {LE sub CP E pop gt PL 0 eq and{NP}if}D
/Ip {/PN PN 1 add D /Pn RM{1}{4}ie PN Ns D /PM PN SN sub 2 mod D} D
/GP {E dup 3 -1 roll get PN 1 add 2 mod get dup type /integertype eq
 {get 0 get}{E pop}ie}d
/Fc {dup 2 GP exec SW pop /S1 E D dup 1 GP exec SW pop /S2 E D 0 GP exec SW
 pop /S3 E D S1 0 gt{S2 2 mul S1 add S3 2 mul S1 add 2 copy lt{E}if pop}{0}ie
 S2 S3 add 2 copy lt{E}if pop IW .9 mul div dup 1 gt{1 E div}{pop 1}ie}D
/OR {gsave SA{1 Sf div dup scale}if Fe{Cf{FU VC}if FW LW 1 setlinejoin
 FE stroke}if /YO {60 F div dup 40 gt{pop 40}if}D /cs CS D /cf CF D /CF 0 D
 /pf PF D /PF f D /Fn FN D /At AT D /AT 0 D /FN EF Hf 1 add get D Fz Fs FS ZZ
 Fc Fz mul Fs FS EU Hf 1 add get dup type /arraytype eq Cf and{VC}{pop 0 Sg}ie
 IW IL neg YO sub M ZZ 1 GP exec dup SW pop neg 0 R Sh 0 IL neg YO sub M
 ZZ 0 GP exec Sh ZZ 2 GP exec dup SW pop IW E sub 2 div IL neg YO sub M Sh
 Fz Fs FS NO{/AW IW Pn SW pop sub D AW 2 div IL neg YO sub
 S1 0 gt S2 AW .45 mul gt or S3 AW .45 mul gt or{Fz 2 mul sub}if M Pn Sh}if
 EU Hf get dup type /arraytype eq Cf and{VC}{pop 0 Sg}ie
 YY Fc /FN EF Hf get D Hz mul HS FS IW YO M YY 1 GP exec dup SW pop neg 0 R Sh
 0 YO M YY 0 GP exec Sh YY 2 GP exec dup SW pop IW E sub 2 div YO M Sh
 /FN Fn D /AT At D t Pb XO SZ SL get neg R /PF pf D grestore /CF 0 D cs cf FS}D
/Sh {dup () ne{CP Hz 4 div sub BB show CP CS add BB}{pop}ie}D
/Pb {/OU E D /Ou OU D /PB t D 0 0 M Ba{/Sa save D /BP t D /Fl t D RC /PL 0 D
 /PH 0 D /W IW D /LE IL .7 mul D /EO 0 D SI ZF /YA 0 D /BO 0 D /C1 () D
 BA 0 Ts neg R Bb{Xl Yl Xh Yh}if Bb CP Sa restore M
 {/Yh E D /Xh E D /Yl E D /Xl E D}if /Fl t D}if
 BL /OU t D /HM f D /Ou t D /PB f D} D
/Bs {/BP Ba not D}D
/reencodeISO {
 dup dup findfont dup length dict begin{1 index /FID ne{D}{pop pop}ie}forall
 /Encoding ISOLatin1Encoding D currentdict end definefont} D
/ISOLatin1Encoding [
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright
/parenleft/parenright/asterisk/plus/comma/hyphen/period/slash
/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon
/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N
/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright
/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m
/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/space/exclamdown/cent/sterling/currency/yen/brokenbar
/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot
/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior
/acute/mu/paragraph/periodcentered/cedilla/onesuperior/ordmasculine
/guillemotright/onequarter/onehalf/threequarters/questiondown
/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla
/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex
/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis
/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute
/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis
/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave
/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex
/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis
/yacute/thorn/ydieresis
] D
[128/backslash 129/parenleft 130/parenright 141/circumflex 142/tilde
143/perthousand 144/dagger 145/daggerdbl 146/Ydieresis 147/scaron 148/Scaron
149/oe 150/OE 151/guilsinglleft 152/guilsinglright 153/quotesinglbase
154/quotedblbase 155/quotedblleft 156/quotedblright 157/endash 158/emdash
159/trademark]
aload length 2 idiv 1 1 3 -1 roll{pop ISOLatin1Encoding 3 1 roll put}for
/colorimage where{pop}{
 /colorimage {
  pop pop /Pr E D {/Cv Pr D /Gr Cv length 3 idiv string D 0 1 Gr length 1 sub
   {Gr E dup /i E 3 mul D Cv i get 0.299 mul Cv i 1 add get 0.587 mul add
    Cv i 2 add get 0.114 mul add cvi put}for Gr} image} D
}ie
/pdfmark where{pop}{userdict /pdfmark /cleartomark load put}ie
WF{FL{reencodeISO D}forall}{4 1 FL length 1 sub{FL E get reencodeISO D}for}ie
/Symbol dup dup findfont dup length dict begin
 {1 index /FID ne{D}{pop pop}ie}forall /Encoding [Encoding aload pop]
 dup 128 /therefore put D currentdict end definefont D

/SF {/CS E D SZ SL CS put FO SL FN put /YI CS LH neg mul D dup ST cvs ( ) join
 CS ST cvs join C1 E join ( NF ) join /C1 E D CS NF /Wf WF FN 0 gt or D
 /BW Wf{( ) SW pop}{0}ie D}D
/NF {/cS E D /cF E D cF 0 ge{FL cF get}{/Symbol}ie
 findfont cS scalefont setfont} D
/FS {CF or /CF E D FR SL CF put CF CF 0 ge{FN 4 mul add}if E SF} D
/PC {SH /BP f D fin not GL not and{NL}if /HM t D /LL LS D} D
/BS {/TX E D Wf{/fin f D /CW 0 D /LK 0 D /SC 0 D
 /RT TX D {RT ( ) search{/NW E D pop /RT E D /WH NW SW pop D CW WH add LL gt
 {TX SC LK SC sub 1 sub NN GI GL{SH cF cS OC
 2 copy cS ne E cF ne or{NF}{pop pop}ie}{PC /CW WH BW add D}ie
 /SC LK D}
 {GL{JC}if
 /CW CW WH add BW add D /HM t D}ie /GL f D /Ph f D
 /LK LK NW length 1 add add D}{pop exit}ie}loop
 /fin t D TX SC LK SC sub GI SH RT () ne{GL not{CC}if}if
 /LC TX length D /WH RT SW pop D CW WH add Hy{HC SW pop add}if LL gt
 {RT GL{SH cF cS OC 2 copy cS ne E cF ne or{NF}{pop pop}ie
 Hy{/Ph t D}if /LL LS D}{NL /LL LS D SH}ie}
 {RT PC Hy{CC}if /Ph Ph Hy or D}ie RT () ne{/GL t D /HM t D}if}
 {TX SW pop LL le{TX SH}{/NW () D 0 2 TX length 1 sub
 {/CW E D TX 0 CW GI dup SW pop LL gt{pop NW SH /HM t D NL/LL W XO sub MR sub D
 /CW CW 2 sub NN D /TX TX CW TX length CW sub GI D TX BS exit}
 {/NW E D}ie}for}ie}ie /HM t D}D
/CC {C0 length 0 gt{JC}if /C0 [C1 L1 YA YB Mf NS NB TB AF Bw] D
 /C1 () D /L0 L1 D /YA 0 D /YB 0 D /Mf 0 D /NS 0 D /NB 0 D}D
/JC {C0 aload length 0 gt{pop pop pop NB add /NB E D NS add /NS E D
 dup Mf gt{/Mf E D}{pop}ie dup YB gt{/YB E D}{pop}ie
 dup YA gt{/YA E D}{pop}ie pop C1 join /C1 E D /C0 [] D}if}D
/OC {C0 length 0 gt{C1 L1 L0 sub YA YB Mf NS NB TB AF Bw GL C0 aload pop
 /Bw E D /AF E D /TB E D /NB E D /NS E D /Mf E D /YB E D /YA E D /C0 [] D
 /L1 E D /C1 E D Ph{HC SH}if NL /GL E D /Bw E D /AF E D /TB E D /NB E D /NS E D
 /Mf E D /YB E D /YA E D /L1 E D /LL W L1 sub XO sub MR sub WH sub D /CW 0 D
 C1 E join /C1 E D}if}D
/BT {/LB t D dup length string copy RS dup dup () ne E ( ) ne and
 {/CI 0 D /LS LL D /LL W L1 sub XO sub MR sub D BS}
 {dup ( ) eq{/GL f D}if dup () eq L1 0 eq or{pop}{SH /BP f D /Ph f D}ie}ie
 /LB f D} D
/BL {CP E pop XO E M} D
/NL {JC /GL f D /SK W XO sub MR sub L1 sub TB{Bw add}if D
 /YA LF{Mf HM Fl not and PF or{LH mul}if}{0 /LF t D}ie YA 2 copy lt{E}if pop D
 C1 () ne{/FB YB Mf SA{Sf mul}if 4 div 2 copy lt{E}if pop D}if Fl{/Ya YA D}if
 CP E pop YA sub YB sub LE neg lt Fl not and PB not and{NP}if NT TL BL
 OU PF not and PB or{/RE L1 TB{Bw sub}if
 W XO sub MR sub div YA YB add LE BO add div 2 copy lt{E}if pop D
 RE 1 gt{BL 1 RE div dup scale}if}if
 AT 2 le{SK AT mul 2 div YA neg R}if
 AT 3 eq{0 YA neg R TB{/NB NB 1 sub D /NS NS 1 sub D}if /NB NB 1 sub NN D
 /A3 NS 6 mul NB add D NS NB add 0 eq
  {/A1 0 D /A2 0 D}
  {NS 0 eq{/A1 SK NB div dup J gt{pop 0}if D /A2 0 D}{J A3 mul SK lt
   {/A1 J D /A2 SK J NB mul sub NS div dup Ab gt{/A1 0 D pop 0}if D}
   {/A1 SK A3 div D /A2 A1 6 mul D}ie}ie}ie /A1 A1 NN D /A2 A2 NN D}if
 AT 4 eq{0 YA neg R PH 2 le{PD 0 lt{/PD L1 D}if PD M1 gt{/M1 PD D}if
 L1 PD sub M2 gt{/M2 L1 PD sub D}if}{DV ID 1 sub get 0 ge{Lo 0 R}if}ie}if
 F0 cF ne Cs cS ne or{F0 Cs NF}if
 /ms Ms D /Ms f D CP FB sub
 C1 cvx exec XO EO sub L1 add TB{BW sub}if dup LM gt{/LM E D}{pop}ie
 PH 0 eq PH 4 eq or Ms and{HF not{/PO t D /AH t D}if
 BB CP YA add E AT 3 eq LB and{A1 sub}if TB{BW sub}if E BB}
 {pop pop}ie Ms HM PH 3 eq and or{/BP f D /Fl f D}if
 /Lo 0 D /L1 0 D /F0 cF D /Cs cS D BP not{0 YB NN neg R}if
 OU f1 and mF not and{k2 /f1 f D}if
 OU PF not and PB or{RE 1 gt{RE dup scale}if}if /Ms ms Ms or D
 /C1 AF{(Cp )}{()}ie D /YA 0 D /YB 0 D BL
 AT 4 eq LB not and PH 3 ge and
 {ID DV length lt{DV ID get dup 0 ge{DO E sub /Lo E D /L1 Lo D}{pop}ie
 /ID ID 1 add D}if}if /T t D CD{/LN LN 1 add D PD}if
 /PD -1 D /NS 0 D /NB 0 D /TB f D /Ph f D /Mf 0 D /HM f D} D
/RS {/TM E D /CN 0 D TM{10 eq{TM CN ( ) PI}if /CN CN 1 add D}forall
 /CN 0 D /BK HM EN and{0}{1}ie D TM
 {dup 32 ne{TM CN 3 2 roll put /CN CN 1 add D /BK 0 D}
 {pop BK 0 eq{TM CN 32 put /CN CN 1 add D}if /BK 1 D}ie}forall
 TM 0 CN GI dup dup () ne E ( ) ne and
 {dup CN 1 sub get 32 eq{/EN f D}{/EN t D}ie}if} D
/join {2 copy length E length add string dup 4 2 roll 2 index 0 3 index
 PI E length E PI}d
/WR {(\n) search{dup () ne BP not or
 {Li 4 le CP E pop YI Li mul add LE add 0 lt and PL 0 eq and{NP}if
 SH NL pop /Li Li 1 sub D WR}{pop pop WR}ie}{SH}ie /CI 0 D /BP f D} D
/SH {dup dup () ne E ( ) ne and PF or CS Mf gt and{/Mf CS D}if
 T not Wf and{( ) E join /T t D}if dup BP{/MF CS D}if
 AT 3 eq{2 copy length dup 0 gt{/NB E NB add D
 {( ) search{/NS NS 1 add D pop pop}{pop exit}ie}loop}{pop pop}ie}if
 CD PD 0 lt and{dup DC search{SW pop /PD E L1 add D pop pop}{pop}ie}if
 0 Np dup SW pop L1 add /L1 E D dup () ne
 {C1 (\() join E join (\)) join AU AF and UF or Wf and{( U ) join}if
 sF{( s ) join}if ( S ) join
 /C1 E D dup length 1 sub get 32 eq /TB E D /Bw BW D}{pop pop}ie} D
/BG {AI LG BC add add 0 eq} D
/ON {OU{Ty AR AI NN get dup 1 add Ln Ns Ty 2 mod 0 eq{(.  )}{(\)  )}ie join
 dup SW pop neg 0 R CP E 0 lt{0 E M}{pop}ie CP BB show /Ms t D}if} D
/Ln {AR AI 3 -1 roll put}D
/SP {dup CI lt BP not and{dup CI sub 0 E R /CI E D}{pop}ie} D
/BN {PF{WR /HM f D}{BT NL}ie} D
/NN {dup 0 lt{pop 0}if} D
/h {HI 0 gt{(h) HI ST cvs join cvx exec dup 1 get E
 Nf{0 get E join}{pop}ie}{()}ie} D
/H {/fn FN D /Hi E 1 add D 1 sub /HL E D /H2 HL 2 add D /GS EZ H2 get D
 E Tm H2 get GS mul BE dup 0 gt{1 sub}{pop EG H2 get dup 0 lt{pop AT}if}ie NA
 WW Np /SL SL 1 add D /FN EF H2 get D GS Ey H2 get FS
 EU H2 get Sc Hs not HL Hl lt and Hs HL hl lt and or Hi 0 eq or
 {/HI Hi D /Hs t D /hl HL D /hL HL D}if HL Hl lt{/hi Hi D}if
 Nf HI 0 gt and{(h) Hi ST cvs join cvx exec 0 get WB}if
 /HF t D /AH f D /PO f D} D
/EH {Bm H2 get GS mul BE OA /SL SL 1 sub NN D /CF 0 D /FN fn D
 SZ SL get FR SL get FS /HF f D /GS Ts D ()Ec} D
/P {E PF{WR}{PO{EP}{BN}ie Ts 4 mul Np AE not{Tm 0 get Ts mul neg SP}if
 dup 0 ge AH and{Pi Pd}if}ie 1 sub dup 0 lt{pop AV AL get}if /AT E D /PO t D} D
/EP {PF{WR}{BN Ts 4 mul Np}ie AE not{Bm 0 get Ts mul neg SP}if
 /AT AV AL get D /PO f D} D
/BE {E PO{EP}{BN}ie Ts 4 mul Np neg SP} D
/HR {/Aw W EO sub D /RW E dup 0 gt{Aw mul}{neg}ie dup Aw gt{pop Aw}if D /RZ E D
 E BN Ts neg SP 1 sub 2 div Aw RW sub mul EO add CP E pop M PF{0 Ps neg R}if
 0 Np OU{gsave RZ LW Cf{Hc VC}{0 Sg}ie CP BB RW 0 RL CP BB stroke grestore}if
 /CI 0 D /BP f D PF not{Ts neg SP}if /Ms t D} D
/AD {I NL EG 14 get dup 0 lt{pop AT}if NA /AE t D Tm 14 get Ts mul neg SP
 Cf{EU 14 get dup -1 eq{pop CA CL get}if Sc}if} D
/DA {BN ()ES OA /AE f D ()Ec Bm 14 get Ts mul neg SP} D
/PR {/MW E D /Li E D Tm 1 get Ps mul BE 0 NA /FN Fp D /PF t D SI /SL SL 1 add D
 /CF 0 D Ps CS mul Ts div MW WC mul CS mul Ts div dup LL gt PL 0 eq and
 {LL div div}{pop}ie Ey 1 get FS CP E pop LE add YI neg div cvi dup Li lt
 AH and{4 lt YI Li mul 5 mul LE add 0 gt or PL 0 eq and{NP}if}{pop}ie
 EU 1 get Sc /GS Ps D}D
/RP {WR NL () /PF f D SI /FN 0 D ES Bm 1 get Ps mul neg SP OA /GS Ts D} D
/SI {/XO Lm 15 get BC NN mul Lm 16 get AI UI sub NN mul add
 Lm 17 get UI NN mul add Lm 20 get LG NN mul add Ts mul
 PF{Lm 1 get Ps mul add}if EO add D
 /MR Rm 15 get BC NN mul Rm 16 get AI UI sub NN mul add
 Rm 17 get UI NN mul add Rm 20 get LG NN mul add Ts mul
 PF{Rm 1 get Ps mul add}if D /LL W XO sub MR sub D} D
/DT {BN /LG LG 1 sub D SI /LG LG 1 add D WW 2 div Np BL} D
/DD {WB Cc 0 eq L1 0 eq or Lm 20 get Ts mul L1 sub TB{BW add}if Ts 2 div lt or
 NL /LF E D SI BL} D
/DL {Dc LG Cc put /Cc E D BG{Tm 18 get Ts mul BE}{BN}ie /LG LG 1 add D BL} D
/LD {BN LG 0 gt{/LG LG 1 sub D}if /Cc Dc LG get D SI
 BG{()Bm 18 get Ts mul BE}if BL} D
/UL {BG{Tm 17 get Ts mul BE}{BN}ie NR AI NN 0 put /UI UI 1 add D
 /AI AI 1 add D SI BL} D
/LU {BN /UI UI 1 sub D /AI AI 1 sub D SI BG{()Bm 17 get Ts mul BE}if BL} D
/OL {E BG{Tm 16 get Ts mul BE}{BN}ie TR AI NN Ty put /Ty E D NR AI NN 1 put
 /AI AI 1 add D SI BL 1 Ln} D
/LO {BN /AI AI 1 sub D /Ty TR AI get D SI BG{()Bm 16 get Ts mul BE}if BL} D
/LI {E BN -1 SP /BP f D /CI 0 D 0 Np NR AI 1 sub NN get 1 eq
 {dup dup 0 gt E 4 le and{/Ty E D}{pop}ie
 /L1 L1 Ty AR AI NN get Ns SW pop XO sub dup 0 lt{pop 0}if add D ( ON )}
 {pop ( B )}ie C1 E join /C1 E D CS Mf gt{/Mf CS D}if BL} D
/BQ {Tm 15 get Ts mul BE /BC BC 1 add D SI BL} D
/QB {Bm 15 get Ts mul BE /BC BC 1 sub D SI BL} D
/Al {E EP 1 sub dup 0 lt{pop AV AL get}if NA} D
/Ea {EP OA} D
/WB {PF{WR}{BT}ie} D
/F1 {WB /FN 0 D CS 0 FS} D
/F2 {WB /FN WI D CS 0 FS} D
/HY {/Hy t D WB /Hy f D} D
/YH {WB} D
/A {/LT E D LT 1 eq{/RN E D}if /Lh E D WB /AF t D /C1 C1 ( Cp ) join D
 Lc{Cl Sc}if} D
/EA {Lc AF and{Ec}{WB}ie TL Pa AF and Lh 0 ne and
 {( \() Lh join (\)) join /AF f D WB}if /AF f D} D
/TL {C1 ( Tl ) apa /C1 E D} d
/apa {AF OU and Lh 0 ne LT 1 eq or and{LT 1 eq{RN ( /) E ST cvs join}
 {(\() Lh join (\)) join}ie E join join}{pop}ie} d
/Cp {/Xc CP /Yc E D D} D
/SS {Cf{dup 0 ge{EU E get dup -1 eq{pop CA CL get}if}{pop CA CL get}ie Sc}
 {pop}ie SZ SL get /SL SL 1 add D} D
/I {WB 8 SS 1 FS} D
/EM {WB 8 SS /CF CF 1 xor D 0 FS} D
/BD {WB 9 SS 2 FS} D
/TT {WB 10 SS /FN Fp D 0 FS} D
/KB {WB 11 SS /FN Fp D 2 FS} D
/CT {WB 12 SS 1 FS} D
/SM {WB 13 SS /FN Fp D 0 FS} D
/Q {/QL QL 1 add D QO QL 2 mod get La get join WB} D
/EQ {QC QL 2 mod get La get join WB /QL QL 1 sub D} D
/RO {WB -1 SS /CF 0 D 0 FS} D
/SY {WB -1 SS -1 FS} D
/ES {WB /SL SL 1 sub NN D /CF 0 D /FN FO SL get D SZ SL get FR SL get FS ()Ec}D
/FZ {3 sub 1.2 E exp GS mul E WB TL /C1 C1 ( Cp ) join D /SL SL 1 add D 0 FS} D
/Ef {WB TL ()ES /C1 C1 ( Cp ) join D} D
/BZ {dup /Bf E D FZ}D
/Sc {dup -1 ne Cf and{/CL CL 1 add D dup 0 eq{pop [0 0 0]}if
 dup CA E CL E put VS ( VC ) join C1 E join /C1 E D}{pop}ie} D
/Ec {WB Cf{/CL CL 1 sub NN D CA CL get VS ( VC ) join C1 E join /C1 E D}if} D
/VS {dup type /arraytype eq{([) E {ST cvs join ( ) join}forall (]) join}if} D
/VC {{255 div}forall setrgbcolor} D
/Sl {dup type /integertype ne{Ds}if /La E D WB}d
/UN {WB /UF t D} D
/NU {WB /UF f D} D
/SE {WB /sF t D} D
/XE {WB /sF f D} D
/sM {/C1 C1 ( k1 ) join D}d
/eM {/C1 C1 ( k2 ) join D}d
/k1 {/YC CP E pop Ts add D /mF t D /f1 t D}d
/k2 {gsave 3 LW -9 CP E pop Ts 0.2 mul sub M -9 YC L stroke grestore /mF f D}d
/Ac {/AC E D WB}d
/Ca {eA{( \()join AC join(\) )join}if WB}d
/s {OU{gsave 0 CS .25 mul R dup SW pop CJ 0 RL stroke grestore}if}D
/CJ {AT 3 eq LB and{E dup dup length 1 sub A1 mul E
 {( ) search{pop pop E A2 add E}{pop exit}ie}loop 3 -1 roll add
 W CP pop sub 2 copy gt{E}if pop}if}D
/So {/Co E D} D
/SO {C1 Yo ST cvs join ( So ) join /C1 E D (j) SW pop 2 div Pd} D
/Se {E WB CS E div Pd}D
/Pd {dup type /stringtype eq{SW pop}if dup /L1 E L1 add D
 ST cvs ( 0 R ) join C1 E join /C1 E D} D
/Sp {0.35 CO} D
/Sb {-0.2 CO} D
/CO {OV Io Yo put /Yo E CS mul Yo add D /Io Io 1 add D -1.5 Io mul 3 add FZ SO
 CS Yo add dup YA gt{/YA E D}{pop}ie
 Yo neg dup YB gt{/YB E D}{pop}ie} D
/Es {ES /Io Io 1 sub NN D /Yo OV Io get D SO} D
/SB {/N2 0 D 0 1 NI{/N E D{IX N2 get 0 lt{/N2 N2 1 add D}{exit}ie}loop
 /K WS N get FC N get mul D /NY AY N2 get D /BV NY array D
 0 1 NY 1 sub{/TM K string D currentfile TM readhexstring pop pop BV E TM put}
 for BM N BV put /N2 N2 1 add D}for} D
/IC [{/MA E D /MB 0 D}{2 div /MA E D /MB MA D}{/MB E CS sub D /MA CS D}
 {pop /MA YS AB mul D /MB 1 AB sub YS mul D}{pop /MA 0 D /MB 0 D}] D
/IP {BV N get /N N 1 add D} D
/II {/K E D IX K get 0 lt{/EC E D}if /TY E D
 TY 4 eq{/Y E D /X E D}if TY 3 eq{/AB E D}if
 /XW AX K get D /YW AY K get D /IS SG IT K get get D /XS XW IS mul D
 /YS YW IS mul D YS IC TY get exec /MA MA Fl not{3 add}if D} D
/IM {II /ty TY D /xs XS D /ys YS D /ya YA D /yb YB D /ma MA D /mb MB D /k K D
 /ec EC D /BP f D /CI 0 D WB TL L1 xs add dup XO add MR add W gt
 {pop /ma ma Fl{3 add}if D NL /YA ma D /YB mb D /YS ys D /L1 xs D}
 {/L1 E D ma YA gt{/YA ma D}if mb YB gt{/YB mb D}if}ie /TB f D
 OU{CP E pop YS sub LE neg lt Fl not and PB not and{NP /YA ma D /YB mb D}if
 /BP f D ty ST cvs ( ) join IX k get 0 lt{(\() join ec join (\) ) join}if
 k ST cvs join ty 3 eq{AB ST cvs ( ) join E join}if
 ty 4 eq{X ST cvs ( ) join Y ST cvs join ( ) join E join}if C1 E join
 ( DI ) join FP 2 eq FP 1 eq AF and or{( FM ) join}if
 ( Il Cp ) apa /C1 E D /EN f D}if /HM t D /T f D} D
/DI {II /Xc CP /Yc E D D /YN YW neg D /HM t D /CI 0 D /K2 IX K get D gsave
 TY 4 eq{OX X IS mul add OY FY add YS sub Y IS mul sub}
 {/FY YS D CP MB sub 2 copy /OY E D /OX E D}ie
 translate K2 0 ge{/DP AZ K2 get D /BV BM K2 get D XS YS scale /N 0 D XW YW DP
 [XW 0 0 YN 0 YW] {IP} FC K2 get 1 eq{image}{f 3 colorimage}ie}
 {EX}ie grestore XS 0 R /Ms t D} D
/FM {gsave 0 Sg CP MB sub translate XS neg 0 M 0 YS RL XS 0 RL 0 YS neg RL
 XS neg 0 RL stroke grestore} D
/NA {/AT E D /AL AL 1 add D AV AL AT put} D
/OA {AL 0 gt{/AL AL 1 sub D /AT AV AL get D}if} D
/D1 {/BR {CP E pop E BN Mb{CP E pop eq{0 YI R}if}{pop}ie} D
 /Sn {OU{C1 E ST cvs join ( Ld ) join /C1 E D}{pop}ie} D} D
/D1 {/BR {BN} D /Sn {OU {C1 E ST cvs join ( Ld ) join /C1 E D} {pop} ie} D} D
/TC {/TF t D /ML 0 D HN{SW pop dup ML gt{/ML E D}{pop}ie}forall NP /RM RM not D
 RC /OU Tc D Ep /PN 0 D Ms not TP and{Ip}if /W IW ML sub Ts sub D
 /A0 0 D TH{/BR {( ) join BT} D /Sn {pop} D /Ti () D /Au () D}if} D
/TN {0 eq{E EA PF HF or not XR and{HN E get Xr}{pop}ie}
 {OU{Tn 0 ge{() BN}if /Tn E D}{pop}ie WB}ie} D
/NT {OU LB not and Tn 0 ge and{PL 0 eq{Ms not{CS CF FS}if CP dup
 /y E YA sub D W 9 sub CS -1.8 mul XO L1 add 2 add{y M (.) show}for
 HN Tn get dup SW pop IW E sub y M show CP BB M}if /Tn -1 D}if} D
/Ld {/DN E D HN DN Pn put [/View [/XYZ -4 Fl{PS}{CP YA add US E pop}ie null]
 /Dest DN ST cvs cvn /DEST pdfmark} D
/C {ND 1 eq{1 sub}if TI mul /XO E D NL Nf not{pop()}if 0 3 -1 roll 1 A} D
/OP {BP not{NP}if PN 2 mod 0 eq{NP}if}D
/Ep {Xp PN 2 mod 0 eq and{/Pn (-) D showpage /PM 1 D LA}if}D
/Dg [73 86 88 76 67 68 77] D
/Rd [0 [1 1 0][2 1 0][3 1 0][2 1 1][1 1 1][2 2 1][3 3 1][4 4 1][2 1 2]] D
/Ns {/m E D /c E 32 mul D /j m 1000 idiv D /p j 12 add string D
 c 96 le m 0 gt and{c 32 le {/i 0 D /d 77 D /l 100 D /m m j 1000 mul sub D
  j -1 1 {pop p i d c add put /i i 1 add D}for
  4 -2 0 {/j E D /n m l idiv D /m m n l mul sub D /d Dg j get D
   n 0 gt {/x Rd n get D x 0 get -1 1 {pop p i d c add put /i i 1 add D}for
   p i x 1 get sub Dg x 2 get j add get c add put}if /l l 10 idiv D
  }for p 0 i GI}
  {/i ST length 1 sub D m {1 sub dup 0 ge{dup 26 mod c add 1 add
   ST i 3 -1 roll put 26 idiv dup 0 eq{pop exit}if}if /i i 1 sub D}loop
   ST i ST length i sub GI}ie}
 {m p cvs}ie} D
/US {matrix currentmatrix matrix defaultmatrix matrix invertmatrix
 matrix concatmatrix transform} D
/GB {Gb{US}if}D
/Tl {/Rn E D Xc CP pop ne{
 [/Rect [Xc 1 sub Yc cS 0.25 mul sub GB CP E 1 add E cS 0.85 mul add GB]
  /Subtype /Link /Border [0 0 Cf Lc and LX and AU or{0}{1}ie] Rn type
  /nametype eq {/Dest Rn}{/Action [/Subtype /URI /URI Rn] Cd}ie
  /ANN pdfmark}if} D
/Il {/Rn E D [/Rect [Xc Yc GB Xc XS add Yc YS add GB] /Subtype /Link
 /Border [0 0 0] Rn type /nametype eq{/Dest Rn}
 {/Action [/Subtype /URI /URI Rn] Cd}ie /ANN pdfmark} D
/XP {[{/Z Bz 2 div D Z 0 R Z Z RL Z neg Z RL Z neg Z neg RL Z Z neg RL}
 {Bz 0 RL 0 Bz RL Bz neg 0 RL 0 Bz neg RL}
 {0 -5 R Bz 0 RL 0 21 RL Bz neg 0 RL 0 -21 RL}]} D
/MS {/Sm E D WB}D
/O {BN()Sm BX} D
/BX {/Bt E D Bt 2 lt{CS 0.8 mul}{11 mul}ie W XO sub MR sub 2 copy gt{E}if pop
 /HZ E D WB Bt 2 eq{HZ ST cvs ( ) join}{()}ie
 Bt ST cvs join ( Bx ) join HM{( ) Pd}if
 L1 HZ add XO add MR add W gt{NL}if C1 E join /C1 E D /L1 L1 HZ add D /T f D
 ( ) WB Bt 2 lt{YA CS .8 mul lt{/YA CS .8 mul D}if}
 {YB 5 lt{/YB 5 D}if YA 21 lt{/YA 21 D}if}ie /CI 0 D} D
/Bx {dup 2 eq{E /Bz E D}{/Bz CS .8 mul D}ie
 OU {gsave 0 Sg XP E get exec stroke grestore}{pop}ie Bz 0 R /Ms t D} D
/SD {FD 4 mul Dy add DZ NF newpath 0 0 M DX t charpath pathbbox
 3 -1 roll sub /DY E D E dup /X1 E D sub WM mul WX DY mul add WM DG mul E div
 /DF E D /DR WX DF mul DY mul WM div 2 div D} d
/Sd {gsave 0 IL Di mul neg translate IL IW atan Di 0 eq{neg}if rotate
 FD 4 mul Dy add DZ NF DR X1 sub DY 2 div neg M cD VC DX show grestore} d
/RC {/AI 0 D /LG 0 D /BC 0 D /UI 0 D /PF f D /Cc 0 D /Dc 10 array D
 /NR [0 1 9{pop 0}for] D /La Ds D /AR 10 array D /TR 10 array D /AV 30 array D
 SI /AL -1 D /AT A0 D AT NA /OV 9 array D /Yo 0 D /Co 0 D /Io 0 D /Hy f D
 /Ph f D /CL -1 D Ct Sc}D
/ZF {/FR [0 1 30{pop 0}for] D /SZ [0 1 30{pop 0}for] D /FO [0 1 30{pop 0}for] D
 /SL 0 D /CF 0 D /FN 0 D 0 Ts SF}D
/QO [[(\253\240)(\232)(\234)(\233)(\253)(\273)][(\253\240)(\231)(')(`)(\253)(\273)]] D
/QC [[(\240\273)(\233)(\234)(\234)(\273)(\253)][(\240\273)(`)(')(')(\273)(\253)]] D
/Hf EF length 2 sub D
/Hz EZ Hf get D
/HS Ey Hf get D
/Fz EZ Hf 1 add get D
/Fs Ey Hf 1 add get D
/LE IL D
/Ps EZ 1 get D
/Fp EF 1 get D
/XO 0 D
/YI 0 D
/CI 0 D
/FP 0 D
/WW Ts 7 mul D
/Mf 0 D
/YA 0 D
/YB 0 D
/Cs Ts D
/GS Ts D
/F0 0 D
/NS 0 D
/NB 0 D
/N 0 D
/C0 [] D
/C1 () D
/Lo 0 D
/L1 0 D
/LM 0 D
/PH 0 D
/EC 0 D
/Lh 0 D
/LT 0 D
/CH 1 string D
/ST 16 string D
/CA 9 array D
/HC (\255) D
/HM f D
/PF f D
/EN f D
/TB f D
/UF f D
/sF f D
/AE f D
/AF f D
/BP t D
/CD f D
/PA t D
/GL f D
/T t D
/HF f D
/AH f D
/SA f D
/PB f D
/f1 f D
/mF f D
/OX 0 D
/OY 0 D
/FY 0 D
/EO 0 D
/FB 0 D
/PL 0 D
/Bw 0 D
/PD -1 D
/TP f D
/TH t D
/Ty 4 D
/Tn -1 D
/Fl t D
/LB t D
/PM 1 D
/Ms f D
/Ba f D
/Bb f D
/Hl 3 D
/hl 6 D
/hL 6 D
/Hs f D
/HI 0 D
/hi 0 D
/PO t D
/TE f D
/LF t D
/BO 0 D
/Sm 1 D
/Bf 3 D
/A1 0 D
/A2 0 D
/Ds 3 D
/QL -1 D
/Cb Db D
/Ct Dt D
/Cl Dl D
[/Creator (html2ps version 1.0 beta1) /Author () /Keywords () /Subject ()
 /Title (gd 2.0.1) /DOCINFO pdfmark
/ND 1 D
/HN [1 1 211{pop (??)}for] D
/h1 [(1\240\240)(This is gd 2.0.1 BETA.)] D
/h2 [(1.1\240\240)(gd 2.0.1)] D
/h3 [(1.1.1\240\240)(A graphics library for fast image creation)] D
/h4 [(1.1.2\240\240)(Follow this link to the latest version of this document.)] D
/h5 [(1.1.3\240\240)(Table of Contents)] D
/h6 [(1.1.4\240\240)(Credits and license terms)] D
/h7 [(1.1.5\240\240)(What is gd?)] D
/h8 [(1.1.6\240\240)(What if I want to use another programming language?)] D
/h9 [(1.1.6.1\240\240)(Perl)] D
/h10 [(1.1.6.2\240\240)(Tcl)] D
/h11 [(1.1.6.3\240\240)(Pascal)] D
/h12 [(1.1.6.4\240\240)(Haskell)] D
/h13 [(1.1.6.5\240\240)(REXX)] D
/h14 [(1.1.6.6\240\240)(Any Language)] D
/h15 [(1.1.7\240\240)(What's new in version 2.0.1?)] D
/h16 [(1.1.8\240\240)(What's new in version 2.0?)] D
/h17 [(1.1.9\240\240)(What's new in version 1.8.4?)] D
/h18 [(1.1.10\240\240)(What's new in version 1.8.3?)] D
/h19 [(1.1.11\240\240)(What's new in version 1.8.2?)] D
/h20 [(1.1.12\240\240)(What's new in version 1.8.1?)] D
/h21 [(1.1.13\240\240)(What's new in version 1.8?)] D
/h22 [(1.1.13.1\240\240)(Additional JPEG Information)] D
/h23 [(1.1.14\240\240)(What's new in version 1.7.3?)] D
/h24 [(1.1.15\240\240)(What's new in version 1.7.2?)] D
/h25 [(1.1.16\240\240)(What's new in version 1.7.1?)] D
/h26 [(1.1.17\240\240)(What's new in version 1.7?)] D
/h27 [(1.1.18\240\240)(What's new in version 1.6.3?)] D
/h28 [(1.1.19\240\240)(What's new in version 1.6.2?)] D
/h29 [(1.1.20\240\240)(What's new in version 1.6.1?)] D
/h30 [(1.1.21\240\240)(What's new in version 1.6?)] D
/h31 [(1.1.22\240\240)(What's new in version 1.5?)] D
/h32 [(1.1.23\240\240)(What's new in version 1.4?)] D
/h33 [(1.1.24\240\240)(What's new in version 1.3?)] D
/h34 [(1.1.25\240\240)(What else do I need to use gd?)] D
/h35 [(1.1.26\240\240)(How do I get gd?)] D
/h36 [(1.1.26.1\240\240)(By HTTP)] D
/h37 [(1.1.26.2\240\240)(By FTP)] D
/h38 [(1.1.27\240\240)(How do I build gd?)] D
/h39 [(1.1.27.1\240\240)(For Unix)] D
/h40 [(1.1.27.2\240\240)(For Windows, Mac, Et Cetera)] D
/h41 [(1.1.28\240\240)(gd basics: using gd in your program)] D
/h42 [(1.1.29\240\240)(Webpng: a more powerful gd example)] D
/h43 [(1.2\240\240)(Function and type reference)] D
/h44 [(1.2.1\240\240)(Types)] D
/h45 [(1.2.2\240\240)(Image creation, destruction, loading and saving)] D
/h46 [(1.2.3\240\240)(Drawing Functions)] D
/h47 [(1.2.4\240\240)(Query Functions)] D
/h48 [(1.2.5\240\240)(Fonts and text-handling functions)] D
/h49 [(1.2.6\240\240)(Color-handling functions)] D
/h50 [(1.2.7\240\240)(Copying and resizing functions)] D
/h51 [(1.2.8\240\240)(Miscellaneous Functions)] D
/h52 [(1.2.9\240\240)(Constants)] D
/h53 [(1.2.10\240\240)(About the additional .gd image file format)] D
/h54 [(1.2.11\240\240)(About the .gd2 image file format)] D
/h55 [(1.2.12\240\240)(About the gdIOCtx structure)] D
/h56 [(1.2.13\240\240)(Please tell us you're using gd!)] D
/h57 [(1.2.14\240\240)(If you have problems)] D
/h58 [(1.2.15\240\240)(Alphabetical quick index)] D
/Hr [153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169
170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187
188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205
206 207 208 209 210]D
/HV [1 2 3 3 3 3 3 3 4 4 4 4 4 4 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3
3 3 4 4 3 4 4 3 3 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3]D
/Cn [2 29 0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
0 2 0 0 2 0 0 0 0 15 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]D
Hr length 0 gt{[/PageMode /UseOutlines /DOCVIEW pdfmark}if
/Hn 1 D
0 1 Hr length 1 sub{
 /Bn E D [Cn Bn get dup 0 gt{/Count E HV Bn get Bl ge{neg}if}{pop}ie
 /Dest Hr Bn get dup abs ST cvs cvn E 0 ge{(h)Hn ST cvs join cvx exec dup 1 get
 E Nf{0 get E join}{pop}ie /Hn Hn 1 add D}{()}ie /Title E /OUT pdfmark}for
ZF /FN Fp D Ps 0 FS /WC Wf{( )}{<A1A1>}ie SW pop D
ET RC ZF
/Df f D
/R1 (http://www.boutell.com/gd/) D
/R2 (http://www.libpng.org/pub/png/) D
/R3 (http://www.info-zip.org/pub/infozip/zlib/) D
/R4 (http://www.ijg.org/) D
/R5 (http://www.freetype.org/) D
/R6 (http://freetype.sourceforge.net/) D
/R7 (http://www.boutell.com/) D
/R8 (http://www-genome.wi.mit.edu/ftp/pub/software/WWW/GD.html) D
/R9 (http://www.tcltk.com/ftp/ellson/) D
/R10 (http://www.elj.com/dev/free-pascal/gdfp/) D
/R11 (http://www.numeric-quest.com/haskell/gd/index.html) D
/R12 (http://www.lightlink.com/hessling/RexxGd/index.html) D
/R13 (http://s27w007.pswfs.gov/tgd/) D
/R14 (http://www.unimelb.edu.au/fly/fly.html) D
/R15 (ftp://ftp.uu.net/graphics/jpeg/) D
/R16 (ftp://ftp.uu.net/graphics/jpeg/jpegsrc.v6b.tar.gz) D
/R17 (http://www.faqs.org/faqs/jpeg-faq/) D
/R18 (http://www.freesoftware.com/pub/infozip/index.html) D
/R19 (http://www.cdrom.com/pub/png/) D
/R20 (http://www.boutell.com/gd/http/gd-2.0.1.tar.gz) D
/R21 (http://www.boutell.com/gd/http/gd-2.0.1.zip) D
/R22 (ftp://ftp.boutell.com/pub/boutell/gd/gd-2.0.1.tar.gz) D
/R23 (ftp://ftp.boutell.com/pub/boutell/gd/gd-2.0.1.zip) D
/R24 (http://www.boutell.com/boutell/) D
/TS {
 tables E get /table E D
 table aload pop /rdesc E D /cdesc E D /tdesc E D
 tdesc aload pop /capalg E D /caption E D /rules E D /frame E D /nfoot E D
  /nhead E D /ncol E D /nrow E D /border E D /twid E D /units E D /talign E D
  /flow E D /clear E D /tclass E D pop pop
 /w W D /eps 0.1 D /OU f D /PL 1 D
 /FN EF 21 get D EZ 21 get Ey 21 get FS
 0 1 1{
  /pass E D
  0 1 nrow{
   /irow E D
   /cells rdesc irow get 6 get D
   0 1 ncol{
    /icol E D
    /cell cells icol get D
    cell 0 ne{
     cell aload pop /CB E D pop pop pop
     /DV E D /bot E D /top E D /right E D /left E D /nowrap E D /valign E D
     /dp E D /align E D /rspan E D /cspan E D /cclass E D /ctype E D /cmax E D
     /cmin E D /proc E D
     rspan 0 eq{/rspan nrow irow sub 1 add D}if
     cspan 0 eq{/cspan ncol icol sub 1 add D}if
     pass 0 eq cspan 1 eq and pass 1 eq cspan 1 gt and or{
      /W 1e5 D /LL W D /PH 1 D
      ctype 1 eq{() BD}if
      RC align NA
      AT 4 eq{/CD t D /DC dp D /LN 0 D /M1 0 D /M2 0 D}{/CD f D}ie
      0 0 M /LM 0 D proc exec BN
      AT 4 eq{
       LN array astore cell 15 3 -1 roll put
       cdesc icol get dup dup 5 get M1 lt{5 M1 put}{5 get /M1 E D}ie
       dup 6 get M2 lt{6 M2 put}{6 get /M2 E D}ie
       /LM M1 M2 add D
      }if
      /CD f D
      /thiswid LM left add right add eps add D
      /oldmin 0 D /oldmax 0 D
      0 1 cspan 1 sub{
       icol add cdesc E get dup 2 get /oldmax E oldmax add D
       1 get /oldmin E oldmin add D
      }for
      thiswid oldmax ge{
       0 1 cspan 1 sub{
        icol add cdesc E get dup 2 E 2 get oldmax 0 eq
         {pop thiswid cspan div}{thiswid mul oldmax div}ie
        put
       }for
      }if
      nowrap 1 eq{
       thiswid oldmin ge{
        0 1 cspan 1 sub{
         icol add cdesc E get dup 1 E 1 get oldmin 0 eq
          {pop thiswid cspan div}{thiswid mul oldmin div}ie
         put
        }for
       }if
      }{
       /W 0 D /LL W D /PH 2 D
       ctype 1 eq{() ES () BD}if
       0 0 M /LM 0 D RC proc exec BN
       /thiswid LM left add right add eps add D
       thiswid oldmin ge{
        0 1 cspan 1 sub{
         icol add cdesc E get dup 1 E 1 get oldmin 0 eq
          {pop thiswid cspan div}{thiswid mul oldmin div}ie
         put
        }for
       }if
      }ie
      ctype 1 eq{() ES}if
     }if
    }if
   }for
  }for
 }for
 /tmin 0 D /tmax 0 D
 0 1 ncol{
  cdesc E get dup 1 get E 2 get 2 copy gt{pop dup}if
  tmax add /tmax E D tmin add /tmin E D
 }for
 twid 0 lt{twid neg IW gt{IW neg}{twid}ie /twid E D}if
 tdesc 0 twid neg tmin 2 copy lt{E}if pop put
 tdesc 1 twid neg tmax 2 copy lt{E}if pop put
 /W w D /LL W D /OU t D /PH 0 D /PL 0 D
} D
/PT {
 /PL PL 1 add D
 tables E get /table E D Tm 21 get Ts mul BE
 PL 2 ge{save}if
 /SL SL 1 add D /FN EF 21 get D EZ 21 get Ey 21 get FS
 table aload pop /rdesc E D /cdesc E D /tdesc E D
 tdesc aload pop /capalg E D /caption E D /rules E D /frame E D /nfoot E D
  /nhead E D /ncol E D /nrow E D /border E D /twid E D /units E D /talign E D
  /flow E D /clear E D /tclass E D /tmax E D /tmin E D
 /w W D /xo XO D /mr MR D /ll LL D /lg LG D /ai AI D /bc BC D /nr NR D /ar AR D
 /tr TR D /ui UI D /ph PH D /a0 A0 D /pf PF D /at AT D /av AV D /al AL D
 /Le LE D /la La D
 talign 0 lt{/talign AL 0 gt{AV AL get}{A0 2 le{A0}{0}ie}ie D}if
 ph 1 eq ph 2 eq or{
  NL ph 1 eq{tmax}{tmin}ie dup XO add LM gt{/LM E XO add D}{pop}ie LM E
 }{
  /PH 3 D /LE 1e5 D RC %ZF
  border 0 gt{/border 1 D}if
  /twidth 0 D /avail W xo sub D
  twid 0 eq{0 1 ncol{cdesc E get dup 2 get E 3 get dup 0 gt{div neg dup twid lt
   {/twid E D}{pop}ie}{pop pop}ie}for}if
  /twid twid dup 0 lt{neg avail 2 copy gt{E}if pop}{avail mul}ie D
  /OK t D 0 1 ncol{cdesc E get dup 1 get E 3 get twid mul gt{/OK f D}if}for
  0 1 ncol{
   cdesc E get dup 1 get /colmin E D dup 3 get /cwid E twid mul D dup
   tmax avail le{2 get}if
   tmin avail le tmax avail gt and{
    dup 2 get E 1 get dup 3 1 roll sub avail tmin sub mul tmax tmin sub div add
   }if
   tmin avail gt{1 get}if
   0 E colmin cwid lt OK and{pop cwid}if dup /twidth E twidth add D put
  }for
  /OU f D CP
  tmin twid le{
   0 1 ncol{cdesc E get dup 0 get twidth div twid mul 0 E put}for
   /twidth twid D
  }if
  CP printcap CP E pop sub /caphig E D pop
  0 1 1{
   /pass E D
   0 1 nrow{
    /irow E D
    /cells rdesc irow get 6 get D
    0 1 ncol{
     /icol E D
     /cell cells icol get D
     cell 0 ne{
      cell aload pop /CB E D pop pop pop
      /DV E D /bot E D /top E D /right E D /left E D /nowrap E D /valign E D
      /dp E D /align E D /rspan E D /cspan E D /cclass E D /ctype E D /cmax E D
      /cmin E D /proc E D
      rspan 0 eq{/rspan nrow irow sub 1 add D}if
      cspan 0 eq{/cspan ncol icol sub 1 add D}if
      /W 0 D
      0 1 cspan 1 sub{icol add cdesc E get 0 get /W E W add D}for
      pass 0 eq rspan 1 eq and pass 1 eq rspan 1 gt and or{
       ctype 1 eq{() BD}if
       /W W left sub right sub D /XO 0 D /EO 0 D SI
       /A0 align D RC align NA
       AT 4 eq{
        /DC dp D /DO 0 D /ID 1 D
        0 1 DV length 1 sub{DV E get dup DO gt{/DO E D}{pop}ie}for
        /Lo DO DV 0 get sub D /L1 Lo D
       }if
       0 0 M /BP t D /Fl t D /MF 0 D /FB 0 D
       proc exec T not{/CI 0 D}if BN 0 FB neg R MF 0 eq{/MF CS D}if
       CP /thishig E neg bot add top add CI add D pop
       cell 16 MF put cell 17 Ya put cell 18 thishig put
       valign 4 eq{
        /below thishig Ya sub D
        rdesc irow get dup dup 4 get Ya lt
         {4 Ya put}{4 get /Ya E D}ie
        dup 5 get below lt{5 below put}{5 get /below E D}ie
        /thishig Ya below add D
       }if
       ctype 1 eq{()ES}if
       /oldhig 0 D
       0 1 rspan 1 sub{
        irow add rdesc E get 0 get /oldhig E oldhig add D
       }for
       thishig oldhig ge{
        0 1 rspan 1 sub{
         irow add rdesc E get dup 0 E 0 get oldhig 0 eq
          {pop thishig rspan div}{thishig mul oldhig div}ie
         put
        }for
       }if
      }if
     }if
    }for
   }for
  }for M RC %ZF
  /thight 0 D /racc 0 D /maxh 0 D /brk 0 D /rbeg nhead nfoot add D
  rbeg 1 nrow{
   rdesc E get dup 0 get dup /thight E thight add D
   brk 0 eq{/racc E D}{/racc E racc add D}ie
   racc maxh gt{/maxh racc D}if 2 get /brk E D
  }for
  ph 3 ge{thight caphig add E}if
  ph 0 eq ph 4 eq or{
   /PH 4 D /LE Le D /OU Ou D /yoff 0 D /headsz 0 D
   0 1 nhead 1 sub{rdesc E get 0 get headsz add /headsz E D}for
   /footsz 0 D
   0 1 nfoot 1 sub{rdesc E nhead add get 0 get footsz add /footsz E D}for
   /ahig LE BO add MI add D /maxh maxh headsz add footsz add D
   /thight thight headsz add footsz add D
   tmin avail gt maxh ahig gt or
    {/Sf avail tmin div dup ahig maxh div gt{pop ahig maxh div}if D /SA t D}
    {/Sf 1 D}ie
   tclass 1 eq thight LE 15 sub gt and
    {/SA t D LE 15 sub thight div dup Sf lt{/Sf E D}{pop}ie}if
   SA{Sf Sf scale /ll ll Sf div D /xo xo Sf div D /LE LE Sf div D
    /mr mr Sf div D /BO BO Sf div D /ahig ahig Sf div D}if
   nhead nfoot add getwid
   LE CP E pop add capalg 0 eq{caphig sub}if dup headsz sub footsz sub rwid lt
   E thight lt thight ahig lt and or{NP}if
   capalg 0 eq{printcap -8 SP}if
   CP /ycur E D pop
   printhead
   rbeg 1 nrow{/row E D row
    getwid
    ycur yoff add rwid sub footsz sub LE add 0 lt
    {nfoot 0 gt{printfoot}if Tf NP /rbeg irow1 D
     Ba{MI /MI MI SA{Sf div}if D MI SP /MI E D}if
     CP /ycur E D pop /yoff 0 D printhead}if
    irow1 printrow
   }for
   printfoot /row row 1 add D Tf
   0 ycur yoff add M
   capalg 1 eq{/EO 0 D SI -3 SP printcap}if
   Sf 1 lt{1 Sf div dup scale /ll ll Sf mul D /xo xo Sf mul D /LE LE Sf mul D
    /mr mr Sf mul D /BO BO Sf mul D /SA f D}if
   /EO 0 D
  }if
 }ie
 /W w D /XO xo D /MR mr D /LL ll D /LG lg D /AI ai D /BC bc D /NR nr D /AR ar D
 /TR tr D /UI ui D /PH ph D /A0 a0 D /PF pf D /AT at D /AV av D /AL al D
 /La la D
 /SL SL 1 sub NN D /CF 0 D /FN 0 D SZ SL get FR SL get FS Wf not{()F2}if
 PL 2 ge{Ms E restore Ms or /Ms E D PH 1 eq PH 2 eq or
  {/LM E D}if PH 3 ge{/CI 0 D NL 0 E neg R}if
 }if
 /PL PL 1 sub D /CI 0 D /BP f D /PO f D () Bm 21 get Ts mul BE BL %CF CS SF
} D
/printcap{
 capalg 0 ge{
  SA{/W w Sf div D}
   {talign 1 eq{/XO xo ll twidth sub 2 div add D}if
    talign 2 eq{/XO xo ll twidth sub add D}if
    /W XO twidth add D
   }ie /XO xo D /LL W XO sub MR sub D
  /PA f D /Fl capalg 0 eq D
  1 NA BL caption exec BN OA /PA t D
 }if
} D
/getwid{
 /irow1 E D
 /irow2 irow1 D
 /rwid 0 D
 {rdesc irow2 get dup 0 get rwid add /rwid E D 2 get 0 eq
  {exit}{/irow2 irow2 1 add D}ie
 }loop
} D
/printrow{
 /xoff ll twidth PL 2 ge{Sf div}if sub talign mul 2 div D
 /xleft xoff xo add D
 /irow E D
 /cells rdesc irow get 6 get D
 0 1 ncol{
  /icol E D
  /cell cells icol get D
  cell 0 ne{
   cell aload pop /CB E D /cvsize E D /above E D /fontsz E D
   /DV E D /bot E D /top E D /right E D /left E D /nowrap E D /valign E D
   /dp E D /align E D /rspan E D /cspan E D /cclass E D /ctype E D /cmax E D
   /cmin E D /proc E D
   rspan 0 eq{/rspan nrow irow sub 1 add D}if
   cspan 0 eq{/cspan ncol icol sub 1 add D}if
   /width 0 D
   0 1 cspan 1 sub{icol add cdesc E get 0 get /width E width add D}for
   /rhight rdesc irow get 0 get D
   /hight rhight D
   1 1 rspan 1 sub{irow add rdesc E get 0 get /hight E hight add D}for
   /W xo xoff add width add right sub D
   /EO xo xoff add left add D SI
   Cf{
    gsave CB VC xo xoff add ycur yoff add M
    0 hight neg RL width 0 RL 0 hight RL width neg 0 RL fill
    grestore
   }if
   ctype 1 eq{() BD}if
   /A0 align D RC
   AT 4 eq{
    /DC dp D /ID 1 D /DO cdesc icol get 5 get D /Lo DO DV 0 get sub D /L1 Lo D
   }if
   valign 3 le{0 ycur yoff add top sub
    hight cvsize sub valign 1 sub mul 2 div sub M}
   {0 ycur yoff add top sub above add rdesc irow get 4 get sub M}ie
   /PA f D /BP t D /Fl t D
   BL proc exec BN
   /PA t D
   ctype 1 eq{() ES}if
  }if
  /xoff xoff cdesc icol get 0 get add D
 }for
 /yoff yoff rhight sub D
} D
/printhead {0 1 nhead 1 sub{printrow}for} D
/printfoot {nhead 1 nhead nfoot add 1 sub{printrow}for} D
/Tf {
 OU{rules 2 ge{/yoff 0 D
   gsave 0 Sg
   [0 1 nhead 1 sub{}for rbeg 1 row 1 sub{}for nhead 1 nhead nfoot add 1 sub{}for]{
    /irow E D
    /xoff ll twidth PL 2 ge{Sf div}if sub talign mul 2 div D
    /cells rdesc irow get 6 get D
    0 1 ncol{
     /icol E D
     /cell cells icol get D
     cell 0 ne{
      /rspan cell 6 get D
      /cspan cell 5 get D
      rspan 0 eq{/rspan nrow irow sub 1 add D}if
      cspan 0 eq{/cspan ncol icol sub 1 add D}if
      /width 0 D
      0 1 cspan 1 sub{icol add cdesc E get 0 get /width E width add D}for
      /rhight rdesc irow get 0 get D
      /hight rhight D
      1 1 rspan 1 sub{irow add rdesc E get 0 get /hight E hight add D}for
      xo xoff add width add ycur yoff add M
      0 hight neg icol cspan add 1 sub ncol lt
       {cdesc icol 1 add get 4 get dup rules 3 le{1 eq}{pop t}ie
        {1 eq{0.8}{0.3}ie
        LW RL CP stroke M}{pop R}ie}{R}ie
      irow nhead nfoot add 1 sub ne nfoot 0 eq or
       {irow rspan add 1 sub nrow lt
       {rdesc irow rspan add get 3 get}{nfoot 0 eq{0}{1}ie}ie
       dup rules 2 mod 0 eq{1 eq}{pop t}ie
       {1 eq irow rspan add nhead eq or irow rspan add row eq nfoot 0 gt and or
        {0.8}{0.3}ie LW width neg 0 RL CP stroke M}{pop}ie}if
     }if
     /xoff xoff cdesc icol get 0 get add D
    }for
    /yoff yoff rhight sub D
   }forall
   grestore
   /Ms t D
  }if
  frame 1 gt{
   gsave
   1 LW 0 Sg
   xleft ycur M CP BB
   0 yoff frame 5 eq frame 7 ge or{RL}{R}ie
   twidth 0 frame 3 eq frame 4 eq or frame 8 ge or{RL}{R}ie CP BB
   0 yoff neg frame 6 ge{RL}{R}ie
   twidth neg 0 frame 2 eq frame 4 eq or frame 8 ge or{RL}{R}ie
   closepath stroke
   grestore
   /Ms t D
  }if
 }if
} D
/tables [[[0 0 0 0 0 -1 0 -0 1 7 1 0 0 9 5 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB(0)} 0 0 0 0 1 1 0 (.) 1 0 4 4 2 6 0 0 0 0 Db ]
[{()3 Sl()WB(lower left corner, X position)} 0 0 0 0 1 1 0 (.) 1 0 4 4 2 6 0 0 0 0 Db ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(lower left corner, Y position)} 0 0 0 0 1 1 0 (.) 1 0 4 4 2 6 0 0 0 0 Db ]
[{()} 0 0 0 0 1 1 0 (.) 0 0 4 4 2 6 0 0 0 0 Db]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(lower right corner, X position)} 0 0 0 0 1 1 0 (.) 1 0 4 4 2 6 0 0 0 0 Db ]
[{()} 0 0 0 0 1 1 0 (.) 0 0 4 4 2 6 0 0 0 0 Db]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(3)} 0 0 0 0 1 1 0 (.) 1 0 4 4 2 6 0 0 0 0 Db ]
[{()3 Sl()WB(lower right corner, Y position)} 0 0 0 0 1 1 0 (.) 1 0 4 4 2 6 0 0 0 0 Db ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(4)} 0 0 0 0 1 1 0 (.) 1 0 4 4 2 6 0 0 0 0 Db ]
[{()3 Sl()WB(upper right corner, X position)} 0 0 0 0 1 1 0 (.) 1 0 4 4 2 6 0 0 0 0 Db ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(5)} 0 0 0 0 1 1 0 (.) 1 0 4 4 2 6 0 0 0 0 Db ]
[{()3 Sl()WB(upper right corner, Y position)} 0 0 0 0 1 1 0 (.) 1 0 4 4 2 6 0 0 0 0 Db ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(6)} 0 0 0 0 1 1 0 (.) 1 0 4 4 2 6 0 0 0 0 Db ]
[{()3 Sl()WB(upper left corner, X position)} 0 0 0 0 1 1 0 (.) 1 0 4 4 2 6 0 0 0 0 Db ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(7)} 0 0 0 0 1 1 0 (.) 1 0 4 4 2 6 0 0 0 0 Db ]
[{()3 Sl()WB(upper left corner, Y position)} 0 0 0 0 1 1 0 (.) 1 0 4 4 2 6 0 0 0 0 Db ]
]]
]]
[[0 0 0 0 0 -1 0 -0 0 4 2 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB(All)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 Db ]
[{()3 Sl()WB(\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 Db ]
[{()3 Sl()WB(Must have 'free',)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 Db ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(Anything that reads from the context)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 Db ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 Db ]
[{()3 Sl()WB(Must have 'getC' and 'getBuf',)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 Db ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(Anything that writes to the context)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 Db ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 Db ]
[{()3 Sl()WB(Must have 'putC' and 'putBuf'.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 Db ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(If gdCreateFromGd2Part is called)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 Db ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 Db ]
[{()3 Sl()WB(Must also have 'seek' and 'tell'.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 Db ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(If gdImageGd2 is called)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 Db ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 Db ]
[{()3 Sl()WB(Must also have 'seek' and 'tell'.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 Db ]
]]
]]
] D
0 1 1{TS}for RC ZF

/Cb Db D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc

/Ba f D /BO 0 D Bs
/UR (index.html) D
/Ti (gd 2.0.1) D
/Au () D
/Df f D


NP RC ZF
()3 Sl()WB 0 Sn(

)0 1 0 H(This)WB 153 Sn( is gd 2.0.1 BETA.)EH(
)BD(If you have problems, report them
in detail, and consider using gd 1.8.4 until gd 2.0 final is out.)ES(
)0 P(The gd 2.0 documentation update is not complete, but most new features
are documented to some degree and the what's new section is reasonably
complete. Enjoy!
)0 2 1 H(gd)WB 154 Sn( 2.0.1)EH(
)0 3 2 H(A)WB 155 Sn( graphics library for fast image creation)EH(
)0 3 3 H(Follow)WB 156 Sn( this link to the
)R1 2 A(latest version
of this document)EA(.)EH(
)BQ()BD(HEY! READ THIS!)ES(
gd 2.0.1 creates PNG, JPEG and WBMP images, not GIF images. This is a 
good thing.  PNG is a more compact format, and full compression is
available.  JPEG works well with photographic images, and is still
more compatible with the major Web browsers than even PNG is. WBMP is
intended for wireless devices \201not regular web browsers\202. Existing
code will need modification to call gdImagePng or gdImageJpeg instead
of gdImageGif. )BD(Please do not ask us to send you the old GIF
version of GD.)ES( Unisys holds a patent on the LZW compression
algorithm, which is used in fully compressed GIF images. The best
solution is to move to legally unencumbered, well-compressed,
modern image formats such as PNG and JPEG as soon as possible.

)0 P(gd 2.0.1 )BD(requires)ES( that the following libraries 
also be installed:
)0 P(libpng \201see the )R2 2 A(libpng home page)EA(\202
)0 P(zlib \201see the )R3 2 A(info-zip home page)EA(\202
zlib
)0 P(jpeg-6b or later, if desired \201see the )R4 2 A(Independent JPEG Group home page)EA(\202
)0 P(If you want to use the TrueType font support, you must also
install the )BD(FreeType 2.x library)ES(, including
the header files. See the )R5 2 A(Freetype 
Home Page)EA(, or )R6 2 A(SourceForge)EA(. 
No, I cannot explain why that site is down on a particular day, and no, I 
can't send you a copy.
)0 P(If you want to use the Xpm color bitmap loading support, you must also
have the X Window System and the Xpm library installed \201Xpm is often
included in modern X distributions\202.
)0 P(Please read the documentation and install the required libraries.
Do not send email asking why )SM(png.h)ES( is not found. 
Do not send email asking why )SM(libgd.so)ES( is not found, either.
See the )0 22 1 A(requirements section)22 0 TN TL()Ec /AF f D( for more
information. Thank you!)QB(
)0 3 4 H(Table)WB 157 Sn( of Contents)EH(
)UL()-1 LI()0 1 1 A(Credits and license terms)1 0 TN TL()Ec /AF f D(
)-1 LI()0 4 1 A(What's new in version "XYZ" of GD?)4 0 TN TL()Ec /AF f D(
)-1 LI()0 2 1 A(What is gd?)2 0 TN TL()Ec /AF f D(
)-1 LI()0 3 1 A(What if I want to use another programming language?)3 0 TN TL()Ec /AF f D(
)-1 LI()0 22 1 A(What else do I need to use gd?)22 0 TN TL()Ec /AF f D(
)-1 LI()0 23 1 A(How do I get gd?)23 0 TN TL()Ec /AF f D(
)-1 LI()0 24 1 A(How do I build gd?)24 0 TN TL()Ec /AF f D(
)-1 LI()0 25 1 A(gd basics: using gd in your program)25 0 TN TL()Ec /AF f D(
)-1 LI()0 26 1 A(webpng: a useful example)26 0 TN TL()Ec /AF f D(
)-1 LI()0 27 1 A(Function and type reference by category)27 0 TN TL()Ec /AF f D(
)-1 LI()0 139 1 A(About the additional .gd image file format)139 0 TN TL()Ec /AF f D(
)-1 LI()0 142 1 A()BD(Please)ES(
 tell us you're using gd!)142 0 TN TL()Ec /AF f D(
)-1 LI()0 143 1 A(If you have problems)143 0 TN TL()Ec /AF f D(
)-1 LI()0 144 1 A(Alphabetical quick index)144 0 TN TL()Ec /AF f D()LU(
)0 P()R7 2 A(Up to the )EM(Boutell.Com, Inc. Home Page)ES()EA(
)WB 1 Sn()0 3 5 H(Credits)WB 158 Sn( and license terms)EA()EH(
)0 P(In order to resolve any possible confusion regarding the authorship
of gd, the following copyright statement covers all of the authors
who have required such a statement. )BD(If you are aware of any oversights
in this copyright notice, please contact
)0 2 A(Thomas Boutell)EA( who will be
pleased to correct them.)ES(
) 1 37 PR(COPYRIGHT STATEMENT FOLLOWS THIS LINE)RP(
)BQ(
Portions copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001 by Cold Spring
Harbor Laboratory. Funded under Grant P41-RR02188 by the National
Institutes of Health.
)0 P(Portions copyright 1996, 1997, 1998, 1999, 2000, 2001 by Boutell.Com, Inc.
)0 P(Portions relating to GD2 format copyright 1999, 2000 Philip Warner.
)0 P(Portions relating to PNG copyright 1999, 2000 Greg Roelofs.
)0 P(Portions relating to libttf copyright 1999, 2000 John Ellson \201ellson@lucent.com\202.
)0 P(Portions relating to JPEG and to color quantization copyright 2000, Doug 
Becker and copyright \201C\202 1994-1998, Thomas G. Lane.  This software is based 
in part on the work of the Independent JPEG Group. See the file
README-JPEG.TXT for more information.
)0 P(Portions relating to WBMP copyright 2000 Maurice Szmurlo and Johan Van 
den Brande.
)0 P()BD(Permission has been granted to copy, distribute and modify gd in any
context without fee, including a commercial application, provided that this notice
is present in user-accessible supporting documentation.)ES(
)0 P(This does not affect your ownership of the derived work itself, and the intent
is to assure proper credit for the authors of gd, not to interfere
with your productive use of gd. If you have questions, ask.
"Derived works" includes all programs that utilize the library.
Credit must be given in user-accessible documentation.
)0 P()BD(This software is provided "AS IS.")ES(
The copyright holders disclaim all warranties, either express or implied,
including but not limited to implied warranties of merchantability and
fitness for a particular purpose, with respect to this code and accompanying
documentation.
)0 P(Although their code does not appear in gd 2.0.1, the authors wish to 
thank David Koblas, David Rowley, and Hutchison Avenue Software 
Corporation for their prior contributions.)QB(
) 1 26 PR(END OF COPYRIGHT STATEMENT)RP(
)WB 2 Sn()0 3 6 H(What)WB 159 Sn( is gd?)EH()EA(
)0 P(gd is a graphics library. It allows your code to quickly
draw images complete with lines, arcs, text, multiple
colors, cut and paste from other images, and flood fills, and
write out the result as a PNG or JPEG file. This is particularly
useful in World Wide Web applications, where PNG and JPEG are two
of the formats accepted for inline images by most browsers.
)0 P(gd is not a paint program.
If you are looking for a paint program, you are looking in
the wrong place. If you are not a programmer, you are looking
in the wrong place, unless you are installing a required
library in order to run an application.
)0 P(gd does not provide for every possible desirable graphics
operation. It is not necessary or desirable for gd to become
a kitchen-sink graphics package, but version 2.0 does include
most frequently requested features, including both truecolor and
palette images, resampling \201smooth resizing of truecolor images\202
and so forth.
)0 P()WB 3 Sn()0 3 7 H(What)WB 160 Sn( if I want to use another programming
language?)EH()EA(
Not all of these tools are necessarily up to date and fully compatible
with 2.0.1.
)0 4 8 H(Perl)WB 161 Sn()EH(
gd can also be used from Perl, courtesy of
Lincoln Stein's
)R8 2 A(GD.pm)EA( library, which uses gd as the basis for a set of
Perl 5.x classes. Highly recommended.
)0 4 9 H(Tcl)WB 162 Sn()EH(
gd can be used from Tcl with John Ellson's
)R9 2 A(Gdtclft)EA(
dynamically loaded extension package.
\201Gdtclft2.0 or later is needed for gd-1.6 and up with PNG output.\202
)0 4 10 H(Pascal)WB 163 Sn()EH(
Pascal enthusiasts should look into Michael Bradbury's
)R10 2 A(gdfp)EA( package.
)0 4 11 H(Haskell)WB 164 Sn()EH(
A new gd interface is now available for
)R11 2 A(Haskell
programmers)EA(.
)0 4 12 H(REXX)WB 165 Sn()EH(
A 
)R12 2 A(gd interface 
for the REXX language)EA( is available.
)0 4 13 H(Any)WB 166 Sn( Language)EH(
There are, at the moment, at least three simple interpreters that
perform gd operations. You can output the desired commands to a simple
text file from whatever scripting language you prefer to use, then
invoke the interpreter.
)0 P(
)UL()-1 LI()R13 2 A(tgd)EA(, by Bradley K. Sherman
)-1 LI()R14 2 A(fly)EA(, by Martin Gleeson)LU(
)0 P()WB 4 Sn()0 3 14 H(What's)WB 167 Sn( new in version 2.0.1?)EH()EA(
)UL()-1 LI(Workaround for a bug in gcc, apparently found in gcc 2.7.2 and up.
I reproduced and fixed it while using gcc 2.9.5.2. The bug occurred only
when the -g option was in use. This problem caused gcc to spew
internal error messages unrelated to the correctness of the code
in gd_gd2.c. Howard Jones was first to report it.
)-1 LI()0 76 1 A(gdImageFilledEllipse)76 0 TN TL()Ec /AF f D( documented
and altered; no longer requires a superfluous style argument. Thanks to
Francis James Franklin.
)-1 LI(The Makefile now offers the correct syntax for
optionally creating a static library. Thanks to Jean-Lous Regez,
among others.
)-1 LI(A nested comment, an attempt to return the value of a void function,
and a potentially significant error in gdImageCopyResampled were fixed
thanks to Joseph Shirley.
)-1 LI(A bug preventing proper truecolor text rendering was fixed,
thanks to Jason Gallagher.
)-1 LI()0 98 1 A(gdImageStringFT)98 0 TN TL()Ec /AF f D( \201FreeType\202 should 
now work better against a transparent or semitransparent background,
and should act in a manner consistent with the most recent
)0 82 1 A(gdImageAlphaBlending)82 0 TN TL()Ec /AF f D( setting.
Antialiasing is now done via the alpha channel mechanism if the
image is a truecolor image. 
)-1 LI(Bugs in the output of gdImageArc and gdImageFilledArc were reported
by Bruce Verderaime. A simple and correct but inefficient implementation
has been substituted until fixes are contributed for the faster code,
which is in gd_arc_f_buggy.c along with the test program that reproduces
the bug\201s\202.
)-1 LI()0 75 1 A(gdImageFilledArc)75 0 TN TL()Ec /AF f D( now offers additional
style options, which can be combined to produce various effects.  
)-1 LI(Masahito Yamaga \201ma@yama-ga.com\202 sent a patch to improve
support for Japanese output via )0 98 1 A(gdImageStringFT)98 0 TN TL()Ec /AF f D(. 
He also added a new )SM(readme.jpn)ES( file.
)-1 LI(Zillions of documentation fixes.)LU(
)0 P()WB 5 Sn()0 3 15 H(What's)WB 168 Sn( new in version 2.0?)EH()EA(
)UL()-1 LI()BD(Support for truecolor images!)ES( Version 2.0 can
load truecolor PNGs with no loss of color information, and almost
no loss of alpha channel information. Version 2.0 can also load
truecolor JPEGs with as little loss as possible; however, bear in
mind that JPEG is a lossy format, so repeated load/save cycles
always reduce image quality. This is not a bug. To create
a truecolor image from scratch, call the new
)0 39 1 A(gdImageCreateTrueColor)39 0 TN TL()Ec /AF f D(
function. The )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D( function
is still available to create palette images, and may also be
referred to as )0 145 1 A(gdImageCreatePalette)145 0 TN TL()Ec /AF f D(.
)-1 LI()BD(Support for alpha channels!)ES( In addition to
24 bits of color information for each pixel \201eight bits of
red, green, and blue respectively\202, version 2.0 supports
7 bits of "alpha channel" information. This is used to determine
exactly how transparent the pixel should be. There is also support
for a full 7 bits of transparency for each individual palette index
in a palette-based image. Please note that, as of this writing,
only Macintosh Internet Explorer 5.x and Mozilla/Netscape 6.x
display partial transparency properly.
)-1 LI(The new )0 82 1 A(gdImageAlphaBlending)82 0 TN TL()Ec /AF f D(
function allows for two different modes of drawing. In blending mode,
the alpha channel component of the color supplied to all drawing
functions, such as )0 67 1 A(gdImageSetPixel)67 0 TN TL()Ec /AF f D(,
determines how much of the underlying color should be allowed to
shine through. The resulting image is not transparent. In non-blending 
mode, drawing color is copied literally with the alpha channel 
information, resulting in a transparent image. Blending mode is
not available when drawing on palette images. 
)-1 LI(The )0 122 1 A(gdImageCopyResampled)122 0 TN TL()Ec /AF f D(
function provides "smooth" copying from a large image to a smaller
one, using a weighted average of the pixels of the source area rather 
than selecting one representative pixel. This function is identical
to )0 121 1 A(gdImageCopyResized)121 0 TN TL()Ec /AF f D( when the
destination image is a palette image.
)-1 LI(The )0 146 1 A(gdImageTrueColorToPalette)146 0 TN TL()Ec /AF f D(
function converts a truecolor image to a palette image. The code for
this function was originally drawn from the Independent JPEG Group library
code, which is excellent. The code has been modified to preserve as much
alpha channel information as possible in the resulting palette, in addition 
to preserving colors as well as possible. This does not work as well as
might be hoped. It is usually best to simply produce a truecolor
output image instead, which guarantees the highest output quality.
)-1 LI(A very high degree of backwards compatibility with existing
gd 1.x code has been maintained, at both the source code and binary
level. )BD(Code which directly accesses the )SM(pixels)ES( array
will fail only if it encounters an existing truecolor image)ES(, which may
happen if the code attempts to open and modify an existing JPEG or 
truecolor PNG. Such code should be modified to check the
)SM(trueColor)ES( flag of the )SM(gdImage)ES( structure, and
refer to the )SM(tpixels)ES( array instead when it is set.
)-1 LI(gd is now compiled and installed as a shared library. However,
gd still does not use autoconf, because I \201TBB\202 have very limited
patience with autoconf. These days, most Unix systems provide a fairly
POSIX-standard environment, and the provided Makefile is likely to work well
if users read it and follow the instructions at the top.
)-1 LI(Support for line thickness was added by Michael Schwartz. My apologies
to him for sitting on his patches for so long. See the new
)0 147 1 A(gdImageSetThickness)147 0 TN TL()Ec /AF f D( function, which
affects all standard gd functions that draw lines and curves. In addition,
Michael added a convenient )0 148 1 A(gdImageEllipse)148 0 TN TL()Ec /AF f D(
function. 
)-1 LI(The new )0 75 1 A(gdImageFilledArc)75 0 TN TL()Ec /AF f D( function
provides a straightforward way to draw filled arcs. Also,
)0 76 1 A(gdImageFilledEllipse)76 0 TN TL()Ec /AF f D( is a 
convenient way to fill an ellipse without specifying starting
and ending angles. Thanks go out to F J Franklin.
)-1 LI(To put an end to the confusion, TrueType 1.x support has been
removed in favor of TrueType 2.x support. The old
gdImageStringTTF function simply invokes gdImageStringFT.
)-1 LI(The specialized .gd and .gd2 file formats have been upgraded to support
truecolor. New images written by the versions of these functions
found in 2.0 will be rejected, with varying degrees of grace, by
older versions of gd. THIS AFFECTS THE .GD and .GD2 FORMATS ONLY. IF YOU
ARE CONFUSED BY THIS PARAGRAPH, IT PROBABLY DOESN'T APPLY TO ANYTHING
YOU WILL EVER ENCOUNTER. Since these file formats are absolutely,
positively *not* designed for distributing images, just for
preprocessing them, this should not be a big problem. gd 2.0 should
read old .gd and .gd2 files correctly.)LU(
)0 P()WB 6 Sn()0 3 16 H(What's)WB 169 Sn( new in version 1.8.4?)EH()EA(
)UL()-1 LI(Add support for FreeType2  \201John Ellson  ellson@lucent.com\202
)-1 LI(Add support for finding in fonts in a builtin DEFAULT_FONTPATH,
or in a path from the GDFONTPATH environment variable.
)-1 LI(remove some unused symbols to reduce compiler warnings
)-1 LI(bugfix in size comparisons in gdImageCompare
)-1 LI(REXX now mentioned
)-1 LI(All memory allocation functions are now wrapped within the
library; gdFree is exported and recommended for freeing memory
returned by the gdImage\201Something\202Ptr family of functions.)LU(
)0 P()WB 7 Sn()0 3 17 H(What's)WB 170 Sn( new in version 1.8.3?)EH()EA(
)UL()-1 LI(WBMP output memory leak fixed
)-1 LI()SM(#include <gd.h>)ES( corrected to )SM(#include "gd.h")ES( in gd_wbmp.c 
)-1 LI(Documented the fact that the source and output images shouldn't
match in the WBMP test except for black and white source images)LU(
)0 P()WB 8 Sn()0 3 18 H(What's)WB 171 Sn( new in version 1.8.2?)EH()EA(
)UL()-1 LI(WBMP support debugged and improved by Johann Van den Brande
)-1 LI(WBMP tests added to gdtest.c by Thomas Boutell
)-1 LI(Use of platform-dependent 'install' command removed by Thomas Boutell
)-1 LI(Comments added to Makefile warning users to juggle the order of the
libraries if the linker complains; is there any portable way to do this
automatically, short of using autoconf?
)-1 LI(Documentation of )0 52 1 A(gdImageCreateFromXpm)52 0 TN TL()Ec /AF f D(
corrected
)-1 LI(Updated links to fast-moving, always dodging libpng and zlib web sites)LU(
)0 P()WB 9 Sn()0 3 19 H(What's)WB 172 Sn( new in version 1.8.1?)EH()EA(
)UL()-1 LI(Optional components no longer built by default \201following the
documentation\202
)-1 LI(JPEG code no longer requires inappropriate header files
)-1 LI(Win32 patches from Joe Gregorio
)-1 LI(16-bit font support for bdftogd, from Honza Pazdziora)LU(
)0 P()WB 10 Sn()0 3 20 H(What's)WB 173 Sn( new in version 1.8?)EH()EA(
)UL()-1 LI(Support for JPEG output, courtesy of Doug Becker
)-1 LI(A link to Michael Bradbery's Pascal wrapper
)-1 LI(Support for WBMP output, courtesy of Maurice Szmurlo
)-1 LI(gdImageColorClosestHWB function based on hue, whiteness, blackness,
superior to the regular gdImageColorClosest function, courtesy 
of Philip Warner
)-1 LI(License clarification: yes, you can modify gd)LU(
)0 4 21 H(Additional)WB 174 Sn( JPEG Information)EH(
Support for reading and writing JPEG-format images is courtesy
of Doug Becker and the Independent JPEG Group / Thomas G. Lane.  You
can get the latest version of the IJG JPEG software from )R15 2 A(ftp://ftp.uu.net/graphics/jpeg/)EA(
\201e.g., the )R16 2 A(jpegsrc.v6b.tar.gz)EA(
file\202.  You )BD(must)ES( use
version 6b or later of the IJG JPEG software.  You might also consult
the )R17 2 A(JPEG FAQ)EA( at
)R17 2 A(http://www.faqs.org/faqs/jpeg-faq/)EA(.
)0 P()WB 11 Sn()0 3 22 H(What's)WB 175 Sn( new in version 1.7.3?)EH()EA(
Another attempt at Makefile fixes to permit
linking with all libraries required on platforms with order-
dependent linkers. Perhaps it will work this time.
)0 P()WB 12 Sn()0 3 23 H(What's)WB 176 Sn( new in version 1.7.2?)EH()EA(
An uninitialized-pointer bug in )SM(gdtestttf.c)ES( was corrected.
This bug caused crashes at the end of each call to gdImageStringTTF on
some platforms. Thanks to Wolfgang Haefelinger.
)0 P(Documentation fixes. Thanks to Dohn Arms.
)0 P(Makefile fixes to permit
linking with all libraries required on platforms with order-
dependent linkers.
)0 P()WB 13 Sn()0 3 24 H(What's)WB 177 Sn( new in version 1.7.1?)EH()EA(
A minor buglet in the Makefile was corrected, as well as an inaccurate
error message in )SM(gdtestttf.c)ES(. Thanks to Masahito Yamaga.
)0 P()WB 14 Sn()0 3 25 H(What's)WB 178 Sn( new in version 1.7?)EH()EA(
Version 1.7 contains the following changes:
)UL()-1 LI(Japanese language support for the TrueType functions.
Thanks to Masahito Yamaga.
)-1 LI()SM(autoconf)ES( and )SM(configure)ES( have been removed, in favor of a 
carefully designed Makefile which produces and properly installs
the library and the binaries. System-dependent variables are
at the top of the Makefile for easy modification. I'm sorry, 
folks, but autoconf generated )BD(many, many confused email 
messages)ES( from people who didn't have things where autoconf 
expected to find them. I am not an autoconf/automake wizard, and 
gd is a simple, very compact library which does not need to 
be a shared library. I )BD(did)ES( make many improvements
over the old gd 1.3 Makefile, which were directly inspired by the 
autoconf version found in the 1.6 series \201thanks to John Ellson\202.
)-1 LI(Completely ANSI C compliant, according to the )SM(-pedantic-errors)ES(
flag of gcc. Several pieces of not-quite-ANSI-C code were causing problems
for those with non-gcc compilers.
)-1 LI()SM(gdttf.c)ES( patched to allow the use of Windows symbol
fonts, when present \201thanks to Joseph Peppin\202. 
)-1 LI()SM(extern "C")ES( wrappers added to )SM(gd.h)ES( and the
font header files for the convenience of C++ programmers. 
)SM(bdftogd)ES( was also modified to automatically insert these
wrappers into future font header files. Thanks to John Lindal.
)-1 LI(Compiles correctly on platforms that don't define )SM(SEEK_SET)ES(.
Thanks to Robert Bonomi.
)-1 LI(Loads Xpm images via the 
)0 52 1 A()SM(gdImageCreateFromXpm)ES()52 0 TN TL()Ec /AF f D(
function, if the Xpm library is available. Thanks to Caolan McNamara.)LU(
)0 P()WB 15 Sn()0 3 26 H(What's)WB 179 Sn( new in version 1.6.3?)EH()EA(
Version 1.6.3 corrects a memory leak in gd_png.c. This leak caused
a significant amount of memory to be allocated and not freed when
writing a PNG image. 
)0 P()WB 16 Sn()0 3 27 H(What's)WB 180 Sn( new in version 1.6.2?)EH()EA(
Version 1.6.2 from John Ellson  adds two new functions:
)UL()-1 LI(gdImageStringTTF - scalable, rotatable, anti-aliased, TrueType strings using
the FreeType library, but only if libttf is found by configure.
)BD(We do not provide TrueType fonts. Obtaining them
is entirely up to you.)ES(
)-1 LI(gdImageColorResolve - an efficient alternative for the
common code fragment:
) 3 57 PR(      if \201\201color=gdImageColorExact\201im,R,G,B\202\202 < 0\202
          if \201\201color=gdImageColorAllocate\201im,R,G,B\202\202 < 0\202
              color=gdImageColorClosest\201im,R,G,B\202;)RP()LU(
)0 P(Also in this release the build process has been converted to
GNU autoconf/automake/libtool conventions so that both \201or either\202
static and shared libraries can be built.
)0 P()WB 17 Sn()0 3 28 H(What's)WB 181 Sn( new in version 1.6.1?)EH()EA(
Version 1.6.1 incorporates superior PNG reading and writing code
from Greg Roelofs, with minor modifications by Tom Boutell. 
Specifically, I altered his code to read non-palette images
\201converting them to palette images badly, by dithering them\202,
and to tolerate palette images with types of transparency that
gd doesn't actually support \201it just ignores the advanced
transparency features\202. Any bugs in this area are therefore my 
fault, not Greg's.
)0 P(Unlike gd 1.6, users should have no trouble linking with
gd 1.6.1 if they follow the instructions and install all of
the pieces. However, )BD(If you get undefined symbol errors,
be sure to check for older versions of libpng in your
library directories!)ES(
)0 P()WB 18 Sn()0 3 29 H(What's)WB 182 Sn( new in version 1.6?)EH()EA(
Version 1.6 features the following changes:
)0 P()BD(Support for 8-bit palette PNG images has been added.
Support for GIF has been removed.)ES( This step was taken
to completely avoid the legal controversy regarding the LZW
compression algorithm used in GIF. Unisys holds a patent which
is relevant to LZW compression. PNG is a superior image format
in any case. Now that PNG is supported by both Microsoft
Internet Explorer and Netscape \201in their recent releases\202,
we highly recommend that GD users upgrade in order to get 
well-compressed images in a format which is legally unemcumbered.

)0 P()WB 19 Sn()0 3 30 H(What's)WB 183 Sn( new in version 1.5?)EH()EA(

Version 1.5 featured the following changes:

)0 DL()DT()BD(New GD2 format)ES(
)DD(      An improvement over the GD format, the GD2 format uses the zlib
          compression library to compress the image in chunks. This results
          in file sizes comparable to GIFs, with the ability to access parts
          of large images without having to read the entire image into memory.
)0 P( This format also supports version numbers and rudimentary validity
 checks, so it should be more 'supportable' than the previous GD format.
)0 P()DT()BD(Re-arranged source files)ES(
)DD(      gd.c has been broken into constituant parts: io, gif, gd, gd2 and
          graphics functions are now in separate files.
)0 P()DT()BD(Extended I/O capabilities.)ES(
)DD(      The source/sink feature has been extended to support GD2 file formats \201which
          require seek/tell functions\202, and to allow more general non-file I/O.
)0 P()DT()BD(Better support for Lincoln Stein's Perl Module)ES(
)DD(      The new gdImage*Ptr function returns the chosen format stored in a block of memory.
          This can be directly used by the GD perl module.
)0 P()DT()BD(Added functions)ES(
)DD(gdImageCreateFromGd2Part - allows retrieval of part of an image \201good for huge images, like maps\202,
)BR(gdImagePaletteCopy - Copies a palette from one image to another, doing it's best to match the colors in the target image to the colors in the source palette.
)BR(gdImageGd2, gdImageCreateFromGd2 - Support for new format
)BR(gdImageCopyMerge - Merges two images \201useful to highlight part of an image\202
)BR(gdImageCopyMergeGray - Similar to gdImageCopyMerge, but tries to preserve source image hue.
)BR(gdImagePngPtr, gdImageJpegPtr, gdImageWBMPPtr, gdImageGdPtr, gdImageGd2Ptr - return memory blocks for each type of image.
)BR(gdImageCreateFromPngCtx, gdImageCreateFromGdCtx, gdImageCreateFromGd2Ctx, gdImageCreateFromGd2PartCtx - Support for new I/O context.
)LD(

)BD(NOTE:)ES( In fairness to Thomas Boutell, any bug/problems with any of the above features should
probably be reported to )0 2 A(Philip Warner)EA(.

)0 P()WB 20 Sn()0 3 31 H(What's)WB 184 Sn( new in version 1.4?)EH()EA(

Version 1.4 features the following changes:
)0 DL()DT(Fixed polygon fill routine \201again\202
)DD(Thanks to Kirsten Schulz, version 1.4 is able to fill
numerous types of polygons that caused problems with
previous releases, including version 1.3.
)DT(Support for alternate data sources
)DD(Programmers who wish to load a GIF from something other
than a stdio FILE * stream can use the new
)0 44 1 A(gdImageCreateFromPngSource)44 0 TN TL()Ec /AF f D( function.
)DT(Support for alternate data destinations
)DD(Programmers who wish to write a GIF to something other
than a stdio FILE * stream can use the new
)0 58 1 A(gdImagePngToSink)58 0 TN TL()Ec /AF f D( function.
)DT(More tolerant when reading GIFs
)DD(Version 1.4 does not crash when reading certain animated GIFs,
although it still only reads the first frame. Version 1.4 also has
overflow testing code to prevent crashes when reading
damaged GIFs.)LD(
)0 P()WB 21 Sn()0 3 32 H(What's)WB 185 Sn( new in version 1.3?)EH()EA(
Version 1.3 features the following changes:
)0 DL()DT(Non-LZW-based GIF compression code
)DD(Version 1.3 contained GIF compression code that uses simple Run Length
Encoding instead of LZW compression, while still retaining compatibility
with normal LZW-based GIF decoders \201your browser will still like your GIFs\202.
)BD(LZW compression is patented by Unisys. We are currently reevaluating
the approach taken by gd 1.3. The current release of gd does not support
this approach. We recommend that you use the current release, and generate
PNG images.)ES( Thanks to 
Hutchison Avenue Software Corporation for contributing
the RLE GIF code.
)DT(8-bit fonts, and 8-bit font support
)DD(This improves support for European languages. Thanks are due
to Honza Pazdziora  and also to
Jan Pazdziora . Also see the provided bdftogd
Perl script if you wish to convert fixed-width X11 fonts
to gd fonts.
)DT(16-bit font support \201no fonts provided\202
)DD(Although no such fonts are provided in the distribution,
fonts containing more than 256 characters should work if the
gdImageString16 and gdImageStringUp16 routines are used.
)DT(Improvements to the "webpng" example/utility
)DD(The "webpng" utility is now a slightly more useful application. Thanks to
Brian Dowling for this code.
)DT(Corrections to the color resolution field of GIF output
)DD(Thanks to Bruno Aureli.
)DT(Fixed polygon fills
)DD(A one-line patch for the infamous polygon fill bug, courtesy
of Jim Mason. I believe this fix is sufficient. However, if you
find a situation where polygon fills still fail to behave properly,
please send code that demonstrates the problem, )EM(and)ES( a fix if
you have one. Verifying the fix is important.
)DT(Row-major, not column-major
)DD(Internally, gd now represents the array of pixels as
an array of rows of pixels, rather than an array of columns
of pixels. This improves the performance of compression and
decompression routines slightly, because horizontally adjacent
pixels are now next to each other in memory. )BD(This should
not affect properly written gd applications, but applications that
directly manipulate the )SM(pixels)ES( array will require
changes.)ES()LD(
)WB 22 Sn()0 3 33 H(What)WB 186 Sn( else do I need to use gd?)EH()EA(
)0 P(To use gd, you will need an ANSI C compiler. )BD(All popular
Windows 95 and NT C compilers are ANSI C compliant.)ES( Any
full-ANSI-standard C compiler should be adequate. )BD(The cc
compiler released with SunOS 4.1.3 is not an ANSI C compiler.
Most Unix users who do not already have gcc should get it.
gcc is free, ANSI compliant and a de facto industry standard.
Ask your ISP why it is missing.)ES(
)0 P(As of version 1.6, you also need the zlib compression library,
and the libpng library. As of version 1.6.2, you can draw text
using antialiased TrueType fonts if you also have the libttf
library installed, but this is not mandatory.
zlib is available for a variety of platforms from
)R18 2 A(the zlib web site)EA(.
libpng is available for a variety of platforms from
)R19 2 A(the PNG web site)EA(.

)0 P(You will also want a PNG viewer, if you do not already have
one for your system, since you will need a good way to check the
results of your work. Netscape 4.04 and higher, and Microsoft
Internet Explorer 4.0 or higher, both support PNG.
For some purposes you might be happier with a package like 
Lview Pro for Windows or xv for X. There are PNG viewers available 
for every graphics-capable modern operating system, so consult 
newsgroups relevant to your particular system.
)0 P()WB 23 Sn()0 3 34 H(How)WB 187 Sn( do I get gd?)EH()EA(
)0 4 35 H(By)WB 188 Sn( HTTP)EH(
)UL()-1 LI()R20 2 A(Gzipped Tar File \201Unix\202)EA(
)-1 LI()R21 2 A(.ZIP File \201Windows\202)EA()LU(
)0 4 36 H(By)WB 189 Sn( FTP)EH(
)UL()-1 LI()R22 2 A(Gzipped Tar File \201Unix\202)EA(
)-1 LI()R23 2 A(.ZIP File \201Windows\202)EA()LU(
)0 P()WB 24 Sn()0 3 37 H(How)WB 190 Sn( do I build gd?)EH()EA(
)0 P(In order to build gd, you must first unpack the archive you have
downloaded. If you are not familiar with )SM(tar)ES( and
)SM(gunzip)ES( \201Unix\202 or )SM(ZIP)ES( \201Windows\202, please
consult with an experienced user of your system. Sorry, we cannot
answer questions about basic Internet skills.
)0 P(Unpacking the archive will produce a directory called "gd-2.0.1".
)0 P()0 4 38 H(For)WB 191 Sn( Unix)EH(
)SM(cd)ES( to the 2.0.1 directory. Edit the Makefile with
your preferred text editor and make any necessary changes to the
settings at the top, especially if you want Xpm or TrueType support.
Next, type "make install". Because gd 2.0 and above installs
as a shared library, it is necessary to install the library properly
before running gd-based programs.
)0 P(If you get errors, edit the Makefile again, paying special attention
to the INCLUDEDIRS and LIBDIRS settings.
)0 P(IF YOU GET LINKER ERRORS, TRY JUGGLING THE ORDER OF THE -l DIRECTIVES
IN THE MAKEFILE. Some platforms may prefer that the libraries be listed
in the opposite order.
)0 4 39 H(For)WB 192 Sn( Windows, Mac, Et Cetera)EH(
Create a project using your favorite programming environment.
Copy all of the gd files to the project directory. Add )SM(gd.c)ES(
to your project. Add other source files as appropriate. Learning the
basic skills of creating projects with your chosen C environment
is up to you. 
)0 P(If you wish to test the library, type "make test" AFTER you have
successfully executed "make install". This will build
several test programs, including "gddemo". Run gddemo to see some of
the capabilities of gd.
)0 P(gddemo should execute without incident, creating the file
demoout.png. \201Note there is also a file named demoin.png,
which is provided in the package as part of the demonstration.\202
)0 P(Display demoout.png in your PNG viewer. The image should
be 128x128 pixels and should contain an image of the
space shuttle with quite a lot of graphical elements drawn
on top of it.
)0 P(\201If you are missing the demoin.png file, the other items
should appear anyway.\202
)0 P(Look at demoin.png to see the original space shuttle
image which was scaled and copied into the output image.
)0 P()WB 25 Sn()0 3 40 H(gd)WB 193 Sn( basics: using gd in your program)EH()EA(
gd lets you create PNG or JPEG images on the fly. To use gd in your
program, include the file gd.h, and link with the libgd.a
library produced by "make libgd.a", under Unix. Under other
operating systems you will add gd.c to your own project.
)0 P(If you want to use the provided fonts, include
gdfontt.h, gdfonts.h, gdfontmb.h, gdfontl.h and/or gdfontg.h. For
more impressive results, install FreeType 2.x and use the new 
)0 98 1 A(gdImageStringFT)98 0 TN TL()Ec /AF f D(
function. If you are not using the provided Makefile and/or a 
library-based approach, be sure to include the source modules as well in your
project. \201They may be too large for 16-bit memory models,
that is, 16-bit DOS and Windows.\202
)0 P(Here is a short example program. )BD(\201For a more advanced example,
see gddemo.c, included in the distribution. gddemo.c is NOT the same program;
it demonstrates additional features!\202)ES(
)0 P() 51 73 PR(/* Bring in gd library functions */
#include "gd.h"

/* Bring in standard I/O so we can output the PNG to a file */
#include <stdio.h>

int main\201\202 {
        /* Declare the image */
        )0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
        /* Declare output files */
        FILE *pngout, *jpegout;
        /* Declare color indexes */
        int black;
        int white;

        /* Allocate the image: 64 pixels across by 64 pixels tall */
        im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\20164, 64\202;

        /* Allocate the color black \201red, green and blue all minimum\202.
                Since this is the first color in a new image, it will
                be the background color. */
        black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;      

        /* Allocate the color white \201red, green and blue all maximum\202. */
        white = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 255, 255\202;        
        
        /* Draw a line from the upper left to the lower right,
                using white color index. */
        )0 68 1 A(gdImageLine)68 0 TN TL()Ec /AF f D(\201im, 0, 0, 63, 63, white\202;   

        /* Open a file for writing. "wb" means "write binary", important)WR(
                under MSDOS, harmless under Unix. */
        pngout = fopen\201"test.png", "wb"\202;

        /* Do the same for a JPEG-format file. */
        jpegout = fopen\201"test.jpg", "wb"\202;

        /* Output the image to the disk file in PNG format. */
        )0 56 1 A(gdImagePng)56 0 TN TL()Ec /AF f D(\201im, pngout\202;

        /* Output the same image in JPEG format, using the default
                JPEG quality setting. */
        )0 54 1 A(gdImageJpeg)54 0 TN TL()Ec /AF f D(\201im, jpegout, -1\202;

        /* Close the files. */
        fclose\201pngout\202;
        fclose\201jpegout\202;

        /* Destroy the image in memory. */
        )0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;
})RP(
When executed, this program creates an image, allocates
two colors \201the first color allocated becomes the background
color\202, draws a diagonal line \201note that 0, 0 is the upper
left corner\202, writes the image to PNG and JPEG files, and
destroys the image.
)0 P(The above example program should
give you an idea of how the package works.
gd provides many additional functions, which are listed
in the following reference chapters, complete with code
snippets demonstrating each. There is also an
)0 144 1 A(alphabetical index)144 0 TN TL()Ec /AF f D(.
)0 3 41 H(Webpng:)WB 194 Sn()WB 26 Sn( a more powerful gd example)EA()EH(
Webpng is a simple utility program to manipulate PNGs from the
command line. It is written for Unix and similar command-line
systems, but should be easily adapted for other environments.
Webpng allows you to set transparency and interlacing and
output interesting information about the PNG in question.
)0 P(webpng.c is provided in the distribution. Unix users can
simply type "make webpng" to compile the program. Type
"webpng" with no arguments to see the available options.
)0 2 42 H(Function)WB 195 Sn()WB 27 Sn( and type reference)EA()EH(
)UL()-1 LI()0 28 1 A(Types)28 0 TN TL()Ec /AF f D(
)-1 LI()0 37 1 A(Image creation, destruction, loading and saving)37 0 TN TL()Ec /AF f D(
)-1 LI()0 66 1 A(Drawing, styling, brushing, tiling and
filling functions)66 0 TN TL()Ec /AF f D(
)-1 LI()0 83 1 A(Query functions \201not color-related\202)83 0 TN TL()Ec /AF f D(
)-1 LI()0 91 1 A(Font and text-handling functions)91 0 TN TL()Ec /AF f D(
)-1 LI()0 100 1 A(Color handling functions)100 0 TN TL()Ec /AF f D(
)-1 LI()0 119 1 A(Copying and resizing functions)119 0 TN TL()Ec /AF f D(
)-1 LI()0 126 1 A(Miscellaneous Functions)126 0 TN TL()Ec /AF f D(
)-1 LI()0 130 1 A(Constants)130 0 TN TL()Ec /AF f D()LU(
)0 3 43 H(Types)WB 196 Sn()WB 28 Sn()EA()EH(
)0 DL()DT()WB 29 Sn()SM(gdImage)ES()BD(\201TYPE\202)ES()EA(
)DD(The data structure in which gd stores images. )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(, )0 39 1 A(gdImageCreateTrueColor)39 0 TN TL()Ec /AF f D(
and the various image file-loading functions return
a pointer to this type, and the other functions expect to receive
a pointer to this type as their first argument. It is reasonably safe to
examine any of the members of this structure. It is also reasonably
safe to modify individual pixels within the )SM(pixels)ES( 
or )SM(tpixels)ES( arrays. If the )SM(trueColor)ES( flag
is set, the )SM(tpixels)ES( array is valid; otherwise the
)SM(pixels)ES( array is valid.
)0 P(The )SM(colorsTotal)ES(, )SM(red)ES(, )SM(green)ES(,
)SM(blue)ES(, )SM(alpha)ES( and )SM(open)ES( arrays
manage the palette. They are valid only when the )SM(trueColor)ES(
flag is not set. 
The )SM(transparent)ES( value contains the palette index of the first
transparent color as read-only information for backwards compatibility;
gd 2.0 stores this information in the )SM(alpha)ES( array so that
variable transparency can be supported for each palette entry. However,
for truecolor images, )SM(transparent)ES( represents a single
RGB color which is )BD(always 100% transparent)ES(, and this
feature is generally supported by browsers which do not support 
full alpha channels.
) 59 71 PR(typedef struct {
        /* Palette-based image pixels */
        unsigned char ** pixels;
        int sx;
        int sy;
        /* These are valid in palette images only. See also
        /* 'alpha', which appears later in the structure to
                preserve binary backwards compatibility */
        int colorsTotal;
        int red[gdMaxColors];
        int green[gdMaxColors];
        int blue[gdMaxColors]; 
        int open[gdMaxColors];
        /* For backwards compatibility, this is set to the
                first palette entry with 100% transparency,
                and is also set and reset by the 
                gdImageColorTransparent function. Newer
                applications can allocate palette entries
                with any desired level of transparency; however,
                bear in mind that many viewers, notably
                many web browsers, fail to implement
                full alpha channel for PNG and provide
                support for full opacity or transparency only. */
        int transparent;
        int *polyInts;
        int polyAllocated;
        struct gdImageStruct *brush;
        struct gdImageStruct *tile;     
        int brushColorMap[gdMaxColors];
        int tileColorMap[gdMaxColors];
        int styleLength;)WR(
        int stylePos;
        int *style;
        int interlace;
        /* New in 2.0: alpha channel for palettes. Note that only
                Macintosh Internet Explorer and \201possibly\202 Netscape 6
                really support multiple levels of transparency in
                palettes, to my knowledge, as of 2/15/01. Most
                common browsers will display 100% opaque and
                100% transparent correctly, and do something 
                unpredictable and/or undesirable for levels
                in between. TBB */
        int alpha[gdMaxColors]; 
        /* Truecolor flag and pixels. New 2.0 fields appear here at the
                end to minimize breakage of existing object code. */
        int trueColor;
        int ** tpixels;
        /* Should alpha channel be copied, or applied, each time a
                pixel is drawn? This applies to truecolor images only.
                No attempt is made to alpha-blend in palette images,
                even if semitransparent palette entries exist. 
                To do that, build your image as a truecolor image,
                then quantize down to 8 bits. */
        int alphaBlendingFlag;
        /* Should the alpha channel of the image be saved? This affects
                PNG at the moment; other future formats may also
                have that capability. JPEG doesn't. */
        int saveAlphaFlag;
} gdImage;)RP(
)0 P(The order of the structure members may appear confusing, but was chosen
deliberately to increase backwards compatibility with existing gd 1.x-based
binary code that references particular structure members.
)DT(gdImagePtr)WB 30 Sn()EA( )BD(\201TYPE\202)ES(
)DD(A pointer to an image structure. )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(
returns this type, and the other functions expect it as the first
argument.
)DT(gdFont)WB 31 Sn()EA( )BD(\201TYPE\202)ES(
)DD(A font structure. Used to declare the characteristics of a font.
Plese see the files gdfontl.c and gdfontl.h for an example of the
proper declaration of this structure. You can provide your
own font data by providing such a structure and the associated
pixel array. You can determine the width and height of a single
character in a font by examining the w and h members of the
structure. If you will not be creating your own fonts, you will
not need to concern yourself with the rest of the components of this
structure.
) 13 65 PR(typedef struct {
        /* # of characters in font */
        int nchars;
        /* First character is numbered... \201usually 32 = space\202 */
        int offset;
        /* Character width and height */
        int w;
        int h;
        /* Font data; array of characters, one row after another.
                Easily included in code, also easily loaded from
                data files. */
        char *data;
} gdFont;)RP(
)DT(gdFontPtr)WB 32 Sn()EA( )BD(\201TYPE\202)ES(
)DD(A pointer to a font structure. Text-output functions expect these
as their second argument, following the )0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( argument. Two such pointers are declared in the
provided include files gdfonts.h and gdfontl.h.
)DT(gdPoint)WB 33 Sn()EA( )BD(\201TYPE\202)ES(
)DD(Represents a point in the coordinate space of the image; used
by )0 70 1 A(gdImagePolygon)70 0 TN TL()Ec /AF f D( and
)0 72 1 A(gdImageFilledPolygon)72 0 TN TL()Ec /AF f D(.
) 3 23 PR(typedef struct {
        int x, y;
} gdPoint, *gdPointPtr;)RP(
)DT(gdPointPtr)WB 34 Sn()EA( )BD(\201TYPE\202)ES(
)DD(A pointer to a )0 33 1 A(gdPoint)33 0 TN TL()Ec /AF f D( structure; passed
as an argument to )0 70 1 A(gdImagePolygon)70 0 TN TL()Ec /AF f D(
and )0 72 1 A(gdImageFilledPolygon)72 0 TN TL()Ec /AF f D(.)LD(
)DT(gdSource)WB 35 Sn()EA( )BD(\201TYPE\202)ES(
)DD() 4 61 PR(typedef struct {
        int \201*source\202 \201void *context, char *buffer, int len\202;
        void *context;
} gdSource, *gdSourcePtr;)RP(
Represents a source from which a PNG can be read.
Programmers who do not wish to read PNGs from a file can provide
their own alternate input mechanism, using the
)0 44 1 A(gdImageCreateFromPngSource)44 0 TN TL()Ec /AF f D( function.
See the documentation of that function for an example of the
proper use of this type.
)DT(gdSink)WB 36 Sn()EA( )BD(\201TYPE\202)ES(
)DD() 4 59 PR(typedef struct {
        int \201*sink\202 \201void *context, char *buffer, int len\202;
        void *context;
} gdSink, *gdSinkPtr;)RP(
Represents a "sink" \201destination\202 to which a PNG can be written.
Programmers who do not wish to write PNGs to a file can provide
their own alternate output mechanism, using the
)0 58 1 A(gdImagePngToSink)58 0 TN TL()Ec /AF f D( function.
See the documentation of that function for an example of the
proper use of this type.
)0 3 44 H(Image)WB 197 Sn()WB 37 Sn( creation, destruction, loading and saving)EA()EH(
)0 DL()DT(gdImageCreate\201sx,)WB 38 Sn( sy\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageCreate is called to create palette-based images, with no
more than 256 colors. Invoke gdImageCreate
with the x and y dimensions of the desired image. gdImageCreate
returns a )0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( to the new image, or
NULL if unable to
allocate the image. The image must eventually be destroyed
using )0 53 1 A(gdImageDestroy\201\202)53 0 TN TL()Ec /AF f D(.
) 5 27 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
im = gdImageCreate\20164, 64\202;
/* ... Use the image ... */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(gdImageCreateTrueColor\201sx,)WB 39 Sn( sy\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageCreateTrueColor is called to create truecolor images, with 
an essentially unlimited number of colors. Invoke gdImageCreateTrueColor
with the x and y dimensions of the desired image. gdImageCreateTrueColor
returns a )0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( to the new image, or
NULL if unable to
allocate the image. The image must eventually be destroyed
using )0 53 1 A(gdImageDestroy\201\202)53 0 TN TL()Ec /AF f D(.
)0 P(Truecolor images are always filled with black at creation time.
) 5 36 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
im = gdImageCreateTrueColor\20164, 64\202;
/* ... Use the image ... */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(gdImageCreateFromJpeg\201FILE)WB 40 Sn( *in\202)EA(
)BD(\201FUNCTION\202)ES(
)BR(gdImageCreateFromJpegCtx\201FILE)WB 41 Sn( *in\202)EA(
)BD(\201FUNCTION\202)ES(
)0 P()DT(gdImageCreateFromJpeg\201FILE)WB 40 Sn( *in\202)EA(
)BD(\201FUNCTION\202)ES(
)BR(gdImageCreateFromJpegCtx\201FILE)WB 41 Sn( *in\202)EA(
)BD(\201FUNCTION\202)ES(
)0 P()DD(gdImageCreateFromJpeg is called to load images from JPEG format files.
Invoke gdImageCreateFromJpeg with an already opened pointer to a file
containing the desired image.
gdImageCreateFromJpeg
returns a )0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( to the new 
truecolor image, or NULL
if unable to load the image \201most often because the file is corrupt or
does not contain a JPEG image\202. gdImageCreateFromJpeg does )EM(not)ES(
close the file. You can inspect the sx and sy members of the
image to determine its size. The image must eventually be destroyed
using )0 53 1 A(gdImageDestroy\201\202)53 0 TN TL()Ec /AF f D(. )BD(The
returned image is always a truecolor image.)ES( 
) 8 31 PR()0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
... inside a function ...
FILE *in;
in = fopen\201"myjpeg.jpg", "rb"\202;
im = gdImageCreateFromJpeg\201in\202;
fclose\201in\202;
/* ... Use the image ... */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(gdImageCreateFromPng\201FILE)WB 42 Sn( *in\202)EA(
)BD(\201FUNCTION\202)ES(
)BR(gdImageCreateFromPngCtx\201)WB 43 Sn()0 141 1 A(gdIOCtx)141 0 TN TL()Ec /AF f D( *in\202)EA(
)BD(\201FUNCTION\202)ES(
)0 P()DD(gdImageCreateFromPng is called to load images from PNG format files.
Invoke gdImageCreateFromPng with an already opened pointer to a file
containing the desired image.
gdImageCreateFromPng
returns a )0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( to the new image, or NULL
if unable to load the image \201most often because the file is corrupt or
does not contain a PNG image\202. gdImageCreateFromPng does )EM(not)ES(
close the file. You can inspect the sx and sy members of the
image to determine its size. The image must eventually be destroyed
using )0 53 1 A(gdImageDestroy\201\202)53 0 TN TL()Ec /AF f D(.
)0 P(If the PNG image being loaded is a truecolor image, the resulting
gdImagePtr will refer to a truecolor image. If the PNG image
being loaded is a palette or grayscale image, the resulting
gdImagePtr will refer to a palette image. gd retains only 8 bits
of resolution for each of the red, green and blue channels, and
only 7 bits of resolution for the alpha channel. The former
restriction affects only a handful of very rare 48-bit color
and 16-bit grayscale PNG images. The second restriction affects
all semitransparent PNG images, but the difference is essentially
invisible to the eye. 7 bits of alpha channel resolution is,
in practice, quite a lot.
) 8 30 PR()0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
... inside a function ...
FILE *in;
in = fopen\201"mypng.png", "rb"\202;
im = gdImageCreateFromPng\201in\202;
fclose\201in\202;
/* ... Use the image ... */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(gdImageCreateFromPngSource\201gdSourcePtr)WB 44 Sn( in\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageCreateFromPngSource is called to load a PNG from
a data source other than a file. Usage is very similar to
the )0 42 1 A(gdImageCreateFromPng)42 0 TN TL()Ec /AF f D( function,
except that the programmer provides a custom data source.
)0 P(The programmer must write an input function which accepts
a context pointer, a buffer, and a number of bytes to be
read as arguments. This function must read the number of
bytes requested, unless the end of the file has been reached,
in which case the function should return zero, or an error
has occurred, in which case the function should return
)SM(-1)ES(. The programmer then creates a
)0 35 1 A(gdSource)35 0 TN TL()Ec /AF f D( structure and sets
the )SM(source)ES( pointer to the input function and
the context pointer to any value which is useful to the
programmer.
)0 P(The example below
implements )0 42 1 A(gdImageCreateFromPng)42 0 TN TL()Ec /AF f D(
by creating a custom data source and invoking gdImageCreateFromPngSource.
) 15 59 PR(static int freadWrapper\201void *context, char *buf, int len\202;

gdImagePtr gdImageCreateFromPng\201FILE *in\202
{
        gdSource s;
        s.source = freadWrapper;
        s.context = in;
        return gdImageCreateFromPngSource\201&s\202;
}

static int freadWrapper\201void *context, char *buf, int len\202
{
        int got = fread\201buf, 1, len, \201FILE *\202 context\202;
        return got;
})RP(
)DT(gdImageCreateFromGd\201FILE)WB 45 Sn( *in\202)EA(
)BD(\201FUNCTION\202)ES(
)BR(gdImageCreateFromGdCtx\201)WB 46 Sn()0 141 1 A(gdIOCtx)141 0 TN TL()Ec /AF f D( *in\202)EA(
)BD(\201FUNCTION\202)ES(
)0 P()DD(gdImageCreateFromGd is called to load images from gd format files.
Invoke gdImageCreateFromGd
with an already opened pointer to a file containing the desired image
in the )0 139 1 A(gd file format)139 0 TN TL()Ec /AF f D(, which is specific to
gd and intended for very fast loading. \201It is )EM(not)ES( intended for
compression; for compression, use PNG or JPEG.\202
gdImageCreateFromGd
returns a )0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( to the new image, or NULL
if unable to load the image \201most often because the file is corrupt or
does not contain a gd format image\202. gdImageCreateFromGd does )EM(not)ES(
close the file. You can inspect the sx and sy members of the
image to determine its size. The image must eventually be destroyed
using )0 53 1 A(gdImageDestroy\201\202)53 0 TN TL()Ec /AF f D(.
) 8 29 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
FILE *in;
in = fopen\201"mygd.gd", "rb"\202;
im = gdImageCreateFromGd\201in\202;
fclose\201in\202;
/* ... Use the image ... */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(

)DT(gdImageCreateFromGd2\201FILE)WB 47 Sn( *in\202)EA(
)BD(\201FUNCTION\202)ES(
)BR(gdImageCreateFromGd2Ctx\201)WB 48 Sn()0 141 1 A(gdIOCtx)141 0 TN TL()Ec /AF f D( *in\202)EA(
)BD(\201FUNCTION\202)ES(
)0 P(
)DD(gdImageCreateFromGd2 is called to load images from gd2 format files.
Invoke gdImageCreateFromGd2
with an already opened pointer to a file containing the desired image
in the )0 139 1 A(gd2 file format)139 0 TN TL()Ec /AF f D(, which is specific to
gd2 and intended for fast loading of parts of large images.
\201It is a compressed format, but generally not as good as maximum
compression of the entire image would be.\202
gdImageCreateFromGd
returns a )0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( to the new image, or NULL
if unable to load the image \201most often because the file is corrupt or
does not contain a gd format image\202. gdImageCreateFromGd2 does )EM(not)ES(
close the file. You can inspect the sx and sy members of the
image to determine its size. The image must eventually be destroyed
using )0 53 1 A(gdImageDestroy\201\202)53 0 TN TL()Ec /AF f D(.
) 8 30 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
FILE *in;
in = fopen\201"mygd.gd2", "rb"\202;
im = gdImageCreateFromGd2\201in\202;
fclose\201in\202;
/* ... Use the image ... */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(

)DT(gdImageCreateFromGd2Part\201FILE)WB 49 Sn( *in, int srcX, int srcY, int w, int h\202)EA(
)BD(\201FUNCTION\202)ES(
)BR(gdImageCreateFromGd2PartCtx\201)WB 50 Sn()0 141 1 A(gdIOCtx)141 0 TN TL()Ec /AF f D( *in\202)EA(
)BD(\201FUNCTION\202)ES(
)0 P(
)DD(gdImageCreateFromGd2Part is called to load parts of images from )0 139 1 A(gd2 format files)139 0 TN TL()Ec /AF f D(.
Invoked in the same way as )0 47 1 A(gdImageCreateFromGd2)47 0 TN TL()Ec /AF f D(,
but with extra parameters
indicating the source \201x, y\202 and width/height of the desired image.
gdImageCreateFromGd2Part returns a )0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( to the
new image, or NULL if unable to load the image.
The image must eventually be destroyed using )0 53 1 A(gdImageDestroy\201\202)53 0 TN TL()Ec /AF f D(.
)0 P()DT(gdImageCreateFromXbm\201FILE)WB 51 Sn( *in\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageCreateFromXbm is called to load images from X bitmap format
files. Invoke gdImageCreateFromXbm
with an already opened pointer to a file containing the desired image.
gdImageCreateFromXbm
returns a )0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( to the new image, or NULL
if unable to load the image \201most often because the file is corrupt or
does not contain an X bitmap format image\202. gdImageCreateFromXbm does
)EM(not)ES( close the file. You can inspect the sx and sy members of the
image to determine its size. The image must eventually be destroyed
using )0 53 1 A(gdImageDestroy\201\202)53 0 TN TL()Ec /AF f D(.
) 8 30 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
FILE *in;
in = fopen\201"myxbm.xbm", "rb"\202;
im = gdImageCreateFromXbm\201in\202;
fclose\201in\202;
/* ... Use the image ... */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(gdImageCreateFromXpm\201char)WB 52 Sn( *filename\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageCreateFromXbm is called to load images from XPM X Window System
color bitmap format files. This function is available only if HAVE_XPM
is selected in the Makefile and the Xpm library is linked with the
application. Unlike most gd file functions, the Xpm functions require
filenames, not file pointers. 
gdImageCreateFromXpm
returns a )0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( to the new image, or NULL
if unable to load the image \201most often because the file is corrupt or
does not contain an XPM bitmap format image\202. You can inspect the sx and sy members of the
image to determine its size. The image must eventually be destroyed
using )0 53 1 A(gdImageDestroy\201\202)53 0 TN TL()Ec /AF f D(.
) 8 30 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
FILE *in;
in = fopen\201"myxpm.xpm", "rb"\202;
im = gdImageCreateFromXpm\201in\202;
fclose\201in\202;
/* ... Use the image ... */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(gdImageDestroy\201gdImagePtr)WB 53 Sn( im\202)EA( )BD(\201FUNCTION\202)ES(
)DD(gdImageDestroy is used to free the memory associated with
an image. It is important to invoke gdImageDestroy before
exiting your program or assigning a new image to
a )0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( variable.
) 6 27 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\20110, 10\202;
/* ... Use the image ... */
/* Now destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(void)WB 54 Sn( gdImageJpeg\201gdImagePtr im, FILE *out, int quality\202)EA(
)BD(\201FUNCTION\202)ES()BR(void gdImageJpegCtx\201gdImagePtr im, gdIOCtx *out, int quality\202)EA(
)BD(\201FUNCTION\202)ES()BR()DD(gdImageJpeg outputs the specified image to the specified
file in JPEG format. The file must be open for writing. Under MSDOS
and all versions of Windows, it is important to use "wb" as opposed
to simply "w" as the mode when opening the file, and under Unix there
is no penalty for doing so. gdImageJpeg does )EM(not)ES(
close the file; your code must do so.
)0 P(If quality is negative, the default IJG JPEG quality value \201which
should yield a good general quality / size tradeoff for most
situations\202 is used.  Otherwise, for practical purposes, quality
should be a value in the range 0-95, higher quality values usually
implying both higher quality and larger image sizes.
)0 P(If you have set image interlacing using
)0 128 1 A(gdImageInterlace)128 0 TN TL()Ec /AF f D(, this function will
interpret that to mean you wish to output a progressive JPEG.  Some
programs \201e.g., Web browsers\202 can display progressive JPEGs
incrementally; this can be useful when browsing over a relatively slow
communications link, for example.  Progressive JPEGs can also be
slightly smaller than sequential \201non-progressive\202 JPEGs.
) 20 48 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black, white;
FILE *out;
/* Create the image */
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 100\202;
/* Allocate background */
white = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 255, 255\202;
/* Allocate drawing color */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;
/* Draw rectangle */
)0 71 1 A(gdImageRectangle)71 0 TN TL()Ec /AF f D(\201im, 0, 0, 99, 99, black\202;
/* Open output file in binary mode */
out = fopen\201"rect.jpg", "wb"\202;
/* Write JPEG using default quality */
gdImageJpeg\201im, out, -1\202;
/* Close file */
fclose\201out\202;
/* Destroy image */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(void*)WB 55 Sn( gdImageJpegPtr\201gdImagePtr im, int *size\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(Identical to gdImageJpeg except that it returns a pointer to a memory
area with the JPEG data. This memory must be freed by the caller when it is
no longer needed. )BD(The caller must invoke gdFree\201\202, not free\201\202, 
unless the caller is absolutely certain that the same implementations of
malloc, free, etc. are used both at library build time and at application
build time.)ES( The 'size' parameter receives the total size of the block
of memory.
)DT(void)WB 56 Sn( gdImagePng\201gdImagePtr im, FILE *out\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImagePng outputs the specified image to the specified
file in PNG format. The file must be open for writing. Under MSDOS
and all versions of Windows, it is important to use "wb" as opposed
to simply "w" as the mode when opening the file, and under Unix there
is no penalty for doing so. gdImagePng does )EM(not)ES(
close the file; your code must do so.
) 20 48 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black, white;
FILE *out;
/* Create the image */
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 100\202;
/* Allocate background */
white = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 255, 255\202;
/* Allocate drawing color */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;
/* Draw rectangle */
)0 71 1 A(gdImageRectangle)71 0 TN TL()Ec /AF f D(\201im, 0, 0, 99, 99, black\202;
/* Open output file in binary mode */
out = fopen\201"rect.png", "wb"\202;
/* Write PNG */
gdImagePng\201im, out\202;
/* Close file */
fclose\201out\202;
/* Destroy image */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(

)DT(void*)WB 57 Sn( gdImagePngPtr\201gdImagePtr im, int *size\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(Identical to gdImagePng except that it returns a pointer to a memory
area with the PNG data. This memory must be freed by the caller when it is
no longer needed. )BD(The caller must invoke gdFree\201\202, not free\201\202, 
unless the caller is absolutely certain that the same implementations of
malloc, free, etc. are used both at library build time and at application
build time.)ES( The 'size' parameter receives the total size of the block
of memory.

)DT(gdImagePngToSink\201gdImagePtr)WB 58 Sn( im, gdSinkPtr out\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImagePngToSink is called to write a PNG to
a data "sink" \201destination\202 other than a file. Usage is very similar to
the )0 56 1 A(gdImagePng)56 0 TN TL()Ec /AF f D( function,
except that the programmer provides a custom data sink.
)0 P(The programmer must write an output function which accepts
a context pointer, a buffer, and a number of bytes to be
written as arguments. This function must write the number of
bytes requested and return that number, unless an error
has occurred, in which case the function should return
)SM(-1)ES(. The programmer then creates a
)0 36 1 A(gdSink)36 0 TN TL()Ec /AF f D( structure and sets
the )SM(sink)ES( pointer to the output function and
the context pointer to any value which is useful to the
programmer.
)0 P(The example below
implements )0 56 1 A(gdImagePng)56 0 TN TL()Ec /AF f D(
by creating a custom data source and invoking gdImagePngFromSink.
) 12 58 PR(static int stdioSink\201void *context, char *buffer, int len\202
{
        return fwrite\201buffer, 1, len, \201FILE *\202 context\202;
}

void gdImagePng\201gdImagePtr im, FILE *out\202
{
        gdSink mySink;
        mySink.context = \201void *\202 out;
        mySink.sink = stdioSink;
        gdImagePngToSink\201im, &mySink\202;
})RP(
)DT(void)WB 59 Sn( gdImageWBMP\201gdImagePtr im, int fg, FILE *out\202)EA(
)BR(gdImageWBMPCtx\201)WB 60 Sn()0 141 1 A(gdIOCtx)141 0 TN TL()Ec /AF f D( *out\202)EA(
)BD(\201FUNCTION\202)ES()BD(\201FUNCTION\202)ES(
)DD(gdImageWBMP outputs the specified image to the specified
file in WBMP format. The file must be open for writing. Under MSDOS
and all versions of Windows, it is important to use "wb" as opposed
to simply "w" as the mode when opening the file, and under Unix there
is no penalty for doing so. gdImageWBMP does )EM(not)ES(
close the file; your code must do so.
)0 P()BD(WBMP file support is black and white only. The color index
specified by the fg argument is the "foreground," and only pixels
of this color will be set in the WBMP file.)ES( All other pixels
will be considered "background."
) 20 48 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black, white;
FILE *out;
/* Create the image */
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 100\202;
/* Allocate background */
white = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 255, 255\202;
/* Allocate drawing color */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;
/* Draw rectangle */
)0 71 1 A(gdImageRectangle)71 0 TN TL()Ec /AF f D(\201im, 0, 0, 99, 99, black\202;
/* Open output file in binary mode */
out = fopen\201"rect.wbmp", "wb"\202;
/* Write WBMP, with black as foreground */
gdImageWBMP\201im, black, out\202;
/* Close file */
fclose\201out\202;
/* Destroy image */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(void*)WB 61 Sn( gdImageWBMPPtr\201gdImagePtr im, int *size\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(Identical to gdImageWBMP except that it returns a pointer to a memory
area with the WBMP data. This memory must be freed by the caller when it is
no longer needed. )BD(The caller must invoke gdFree\201\202, not free\201\202, 
unless the caller is absolutely certain that the same implementations of
malloc, free, etc. are used both at library build time and at application
build time.)ES( The 'size' parameter receives the total size of the block
of memory.
)DT(void)WB 62 Sn( gdImageGd\201gdImagePtr im, FILE *out\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageGd outputs the specified image to the specified
file in the )0 139 1 A(gd image format)139 0 TN TL()Ec /AF f D(. The file must
be open for writing. Under MSDOS and all versions of Windows, it is
important to use "wb" as
opposed to simply "w" as the mode when opening the file, and under
Unix there is no penalty for doing so. gdImagePng does )EM(not)ES(
close the file; your code must do so.
)0 P(The gd image format is intended for fast reads and writes of
images your program will need frequently to build other
images. It is )EM(not)ES( a compressed format, and is not intended
for general use.
) 20 48 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black, white;
FILE *out;
/* Create the image */
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 100\202;
/* Allocate background */
white = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 255, 255\202;
/* Allocate drawing color */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;
/* Draw rectangle */
)0 71 1 A(gdImageRectangle)71 0 TN TL()Ec /AF f D(\201im, 0, 0, 99, 99, black\202;
/* Open output file in binary mode */
out = fopen\201"rect.gd", "wb"\202;
/* Write gd format file */
gdImageGd\201im, out\202;
/* Close file */
fclose\201out\202;
/* Destroy image */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(

)DT(void*)WB 63 Sn( gdImageGdPtr\201gdImagePtr im, int *size\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(Identical to gdImageGd except that it returns a pointer to a memory
area with the GD data. This memory must be freed by the caller when it is
no longer needed. )BD(The caller must invoke gdFree\201\202, not free\201\202, 
unless the caller is absolutely certain that the same implementations of
malloc, free, etc. are used both at library build time and at application
build time.)ES( The 'size' parameter receives the total size of the block
of memory.

)DT(void)WB 64 Sn( gdImageGd2\201gdImagePtr im, FILE *out, int chunkSize, int fmt\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageGd2 outputs the specified image to the specified
file in the )0 140 1 A(gd2 image format)140 0 TN TL()Ec /AF f D(. The file must
be open for writing. Under MSDOS and all versions of Windows, it is
important to use "wb" as
opposed to simply "w" as the mode when opening the file, and under
Unix there is no penalty for doing so. gdImageGd2 does )EM(not)ES(
close the file; your code must do so.
)0 P(The gd2 image format is intended for fast reads and writes of
parts of images.
It is a compressed format, and well suited to retrieving smll sections of
much larger images.

The third and fourth parameters are the 'chunk size' and format resposectively.
)0 P(The file is stored as a series of compressed subimages, and the
)BD(Chunk Size)ES( determines the sub-image size - a value of
zero causes the GD library to use the default.
)0 P(It is also possible to store GD2 files in an uncompressed format, in which case the
fourth parameter should be GD2_FMT_RAW.

) 20 48 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black, white;
FILE *out;
/* Create the image */
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 100\202;
/* Allocate background */
white = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 255, 255\202;
/* Allocate drawing color */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;
/* Draw rectangle */
)0 71 1 A(gdImageRectangle)71 0 TN TL()Ec /AF f D(\201im, 0, 0, 99, 99, black\202;
/* Open output file in binary mode */
out = fopen\201"rect.gd", "wb"\202;
/* Write gd2 format file */
gdImageGd2\201im, out, 0, GD2_FMT_COMPRESSED\202;
/* Close file */
fclose\201out\202;
/* Destroy image */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(

)DT(void*)WB 65 Sn( gdImageGd2Ptr\201gdImagePtr im, int chunkSize, int fmt, int *size\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(Identical to gdImageGd2 except that it returns a pointer to a memory
area with the GD2 data. This memory must be freed by the caller when it is
no longer needed. )BD(The caller must invoke gdFree\201\202, not free\201\202, 
unless the caller is absolutely certain that the same implementations of
malloc, free, etc. are used both at library build time and at application
build time.)ES( The 'size' parameter receives the total size of the block
of memory.
)LD(
)0 3 45 H(Drawing)WB 198 Sn()WB 66 Sn( Functions)EA()EH(
)0 DL()DT(void)WB 67 Sn( gdImageSetPixel\201gdImagePtr im, int x, int y, int color\202)EA( )BD(\201FUNCTION\202)ES(
)DD(gdImageSetPixel sets a pixel to a particular color index. Always use
this function or one of the other drawing functions to access pixels;
do not access the pixels of the )0 29 1 A(gdImage)29 0 TN TL()Ec /AF f D( structure
directly.
) 14 69 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black;
int white;
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 100\202;
/* Background color \201first allocated\202 */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;      
/* Allocate the color white \201red, green and blue all maximum\202. */
white = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 255, 255\202;        
/* Set a pixel near the center. */
gdImageSetPixel\201im, 50, 50, white\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(void)WB 68 Sn( gdImageLine\201gdImagePtr im, int x1, int y1, int x2, int y2, int color\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageLine is used to draw a line between two endpoints \201x1,y1 and x2, y2\202.
The line is drawn using the color index specified. Note that the color
index can be an actual color returned by )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D( or one of )0 133 1 A(gdStyled)133 0 TN TL()Ec /AF f D(,
)0 131 1 A(gdBrushed)131 0 TN TL()Ec /AF f D( or )0 135 1 A(gdStyledBrushed)135 0 TN TL()Ec /AF f D(.
) 14 71 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black;
int white;
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 100\202;
/* Background color \201first allocated\202 */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;      
/* Allocate the color white \201red, green and blue all maximum\202. */
white = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 255, 255\202;        
/* Draw a line from the upper left corner to the lower right corner. */
gdImageLine\201im, 0, 0, 99, 99, white\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(void)WB 69 Sn( gdImageDashedLine\201gdImagePtr im, int x1, int y1, int x2, int y2, int color\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageDashedLine is provided )BD(solely for backwards compatibility)ES( with gd 1.0. New programs should draw dashed lines using
the normal )0 68 1 A(gdImageLine)68 0 TN TL()Ec /AF f D( function and the
new )0 81 1 A(gdImageSetStyle)81 0 TN TL()Ec /AF f D( function.
)0 P(gdImageDashedLine is used to draw a dashed line between two endpoints
\201x1,y1 and x2, y2\202.
The line is drawn using the color index specified. The portions of the line
that are not drawn are left transparent so the background is visible.
) 14 78 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black;
int white;
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 100\202;
/* Background color \201first allocated\202 */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;      
/* Allocate the color white \201red, green and blue all maximum\202. */
white = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 255, 255\202;        
/* Draw a dashed line from the upper left corner to the lower right corner. */
gdImageDashedLine\201im, 0, 0, 99, 99\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(void)WB 70 Sn( gdImagePolygon\201gdImagePtr im, gdPointPtr points, int pointsTotal, int color\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImagePolygon is used to draw a polygon with the verticies
\201at least 3\202 specified, using the color index specified.
See also )0 72 1 A(gdImageFilledPolygon)72 0 TN TL()Ec /AF f D(.
) 22 69 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black;
int white;
/* Points of polygon */
)0 33 1 A(gdPoint)33 0 TN TL()Ec /AF f D( points[3];
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 100\202;
/* Background color \201first allocated\202 */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;      
/* Allocate the color white \201red, green and blue all maximum\202. */
white = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 255, 255\202;        
/* Draw a triangle. */
points[0].x = 50;
points[0].y = 0;
points[1].x = 99;
points[1].y = 99;
points[2].x = 0;
points[2].y = 99;
gdImagePolygon\201im, points, 3, white\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(void)WB 71 Sn( gdImageRectangle\201gdImagePtr im, int x1, int y1, int x2, int y2, int color\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageRectangle is used to draw a rectangle with the two corners
\201upper left first, then lower right\202 specified, using the
color index specified.
) 14 69 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black;
int white;
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 100\202;
/* Background color \201first allocated\202 */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;      
/* Allocate the color white \201red, green and blue all maximum\202. */
white = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 255, 255\202;        
/* Draw a rectangle occupying the central area. */
gdImageRectangle\201im, 25, 25, 74, 74, white\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(void)WB 72 Sn( gdImageFilledPolygon\201gdImagePtr im, gdPointPtr points, int pointsTotal, int color\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageFilledPolygon is used to fill a polygon with the verticies
\201at least 3\202 specified, using the color index specified.
See also )0 72 1 A(gdImagePolygon)72 0 TN TL()Ec /AF f D(.
) 28 69 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black;
int white;
int red;
/* Points of polygon */
)0 33 1 A(gdPoint)33 0 TN TL()Ec /AF f D( points[3];
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 100\202;
/* Background color \201first allocated\202 */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;      
/* Allocate the color white \201red, green and blue all maximum\202. */
white = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 255, 255\202;        
/* Allocate the color red. */
red = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 0, 0\202;      
/* Draw a triangle. */
points[0].x = 50;
points[0].y = 0;
points[1].x = 99;
points[1].y = 99;
points[2].x = 0;
points[2].y = 99;
/* Paint it in white */
gdImageFilledPolygon\201im, points, 3, white\202;
/* Outline it in red; must be done second */
)0 70 1 A(gdImagePolygon)70 0 TN TL()Ec /AF f D(\201im, points, 3, red\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(void)WB 73 Sn( gdImageFilledRectangle\201gdImagePtr im, int x1, int y1, int x2, int y2, int color\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageFilledRectangle is used to draw a solid rectangle with the two corners
\201upper left first, then lower right\202 specified, using the
color index specified.
) 14 69 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black;
int white;
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 100\202;
/* Background color \201first allocated\202 */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;      
/* Allocate the color white \201red, green and blue all maximum\202. */
white = )0 101 1 A(int gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 255, 255\202;    
/* Draw a filled rectangle occupying the central area. */
gdImageFilledRectangle\201im, 25, 25, 74, 74, white\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(void)WB 74 Sn( gdImageArc\201gdImagePtr im, int cx, int cy, int w, int h, int s, int e, int color\202)EA(
)BD( \201FUNCTION\202)ES(
)DD(gdImageArc is used to draw a partial ellipse centered at the given point,
with the specified width and height in pixels. The arc begins at
the position in degrees specified by )SM(s)ES( and ends at
the position specified by )SM(e)ES(. The arc is drawn in
the color specified by the last argument. A circle can be drawn
by beginning from 0 degrees and ending at 360 degrees, with
width and height being equal. e must be greater than s. Values greater
than 360 are interpreted modulo 360.
) 14 69 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black;
int white;
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 50\202;
/* Background color \201first allocated\202 */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;      
/* Allocate the color white \201red, green and blue all maximum\202. */
white = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 255, 255\202;        
/* Inscribe an ellipse in the image. */
gdImageArc\201im, 50, 25, 98, 48, 0, 360, white\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(void)WB 75 Sn( gdImageFilledArc\201gdImagePtr im, int cx, int cy, int w, int h, int s, int e, int color, int style\202)EA(
)BD( \201FUNCTION\202)ES(
)DD(gdImageFilledArc is used to draw a partial ellipse centered at the given point,
with the specified width and height in pixels. The arc begins at
the position in degrees specified by )SM(s)ES( and ends at
the position specified by )SM(e)ES(. The arc is filled in
the color specified by the second to last argument. A circle can be drawn
by beginning from 0 degrees and ending at 360 degrees, with
width and height being equal. e must be greater than s. Values greater
than 360 are interpreted modulo 360. The last argument is a bitwise
OR of the following possibilities:
)UL()-1 LI(gdArc
)-1 LI(gdChord
)-1 LI(gdPie \201synonym for gdChord\202
)-1 LI(gdNoFill
)-1 LI(gdEdged)LU(
gdArc and gdChord are mutually exclusive;
gdChord just connects the starting and ending
angles with a straight line, while gdArc produces
a rounded edge. gdPie is a synonym for gdArc.
gdNoFill indicates that the arc or chord should be
outlined, not filled. gdEdged, used together with
gdNoFill, indicates that the beginning and ending
angles should be connected to the center; this is
a good way to outline \201rather than fill\202 a
'pie slice'.

) 14 69 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black;
int white;
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 50\202;
/* Background color \201first allocated\202 */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;      
/* Allocate the color white \201red, green and blue all maximum\202. */
white = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 255, 255\202;        
/* Inscribe a filled pie slice in the image. */
gdImageFilledArc\201im, 50, 25, 98, 48, 0, 45, white, gdArc\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(void)WB 76 Sn( gdImageFilledEllipse\201gdImagePtr im, int cx, int cy, int w, int h, int s, int e, int color\202)EA(
)BD( \201FUNCTION\202)ES(
)DD(gdImageFilledEllipse is used to draw an ellipse centered at the given point,
with the specified width and height in pixels. The ellipse is filled in
the color specified by the last argument. A circle can be drawn
by beginning from 0 degrees and ending at 360 degrees, with
width and height being equal. e must be greater than s. Values greater
than 360 are interpreted modulo 360.
) 14 69 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black;
int white;
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 50\202;
/* Background color \201first allocated\202 */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;      
/* Allocate the color white \201red, green and blue all maximum\202. */
white = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 255, 255\202;        
/* Inscribe a filled ellipse in the image. */
gdImageFilledEllipse\201im, 50, 25, 98, 48, white\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(void)WB 77 Sn( gdImageFillToBorder\201gdImagePtr im, int x, int y, int border, int color\202
)BD( \201FUNCTION\202)ES(
)DD(gdImageFillToBorder floods a portion of the image with the specified
)SM(color)ES(, beginning at the specified point and stopping at
the specified )SM(border)ES( color. For a way of flooding an
area defined by the color of the starting point, see
)0 78 1 A(gdImageFill)78 0 TN TL()Ec /AF f D(.
)0 P(The border color )EM(cannot)ES( be a special color
such as )0 137 1 A(gdTiled)137 0 TN TL()Ec /AF f D(; it must be a proper
solid color. The fill color can be, however.
)0 P(Note that gdImageFillToBorder is recursive. It is not the most
naive implementation possible, and the implementation is
expected to improve, but there will always be degenerate
cases in which the stack can become very deep. This can be
a problem in MSDOS and MS Windows 3.1 environments. \201Of course,
in a Unix or Windows 95/98/NT environment with a proper stack, this is
not a problem at all.\202
) 20 69 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black;
int white;
int red;
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 50\202;
/* Background color \201first allocated\202 */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;      
/* Allocate the color white \201red, green and blue all maximum\202. */
white = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 255, 255\202;        
/* Allocate the color red. */
red = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 0, 0\202;      
/* Inscribe an ellipse in the image. */
gdImageArc\201im, 50, 25, 98, 48, 0, 360, white\202;
/* Flood-fill the ellipse. Fill color is red, border color is
        white \201ellipse\202. */
gdImageFillToBorder\201im, 50, 50, white, red\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(void)WB 78 Sn( gdImageFill\201gdImagePtr im, int x, int y, int color\202
)BD( \201FUNCTION\202)ES(
)DD(gdImageFill floods a portion of the image with the specified
)SM(color)ES(, beginning at the specified point and flooding the
surrounding region of the same color as the starting point.
For a way of flooding a region defined by a specific border
color rather than by its interior color, see
)0 77 1 A(gdImageFillToBorder)77 0 TN TL()Ec /AF f D(.
)0 P(The fill color can be )0 137 1 A(gdTiled)137 0 TN TL()Ec /AF f D(, resulting
in a tile fill using another image as the tile. However,
the tile image cannot be transparent. If the image you wish
to fill with has a transparent color index, call
)0 149 1 A(gdImageTransparent)149 0 TN TL()Ec /AF f D( on the
tile image and set the transparent color index to -1
to turn off its transparency.
)0 P(Note that gdImageFill is recursive. It is not the most
naive implementation possible, and the implementation is
expected to improve, but there will always be degenerate
cases in which the stack can become very deep. This can be
a problem in MSDOS and MS Windows environments. \201Of course,
in a Unix or Windows 95/98/NT environment with a proper stack, this is
not a problem at all.\202
) 20 69 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black;
int white;
int red;
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 50\202;
/* Background color \201first allocated\202 */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;      
/* Allocate the color white \201red, green and blue all maximum\202. */
white = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 255, 255\202;        
/* Allocate the color red. */
red = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 0, 0\202;      
/* Inscribe an ellipse in the image. */
gdImageArc\201im, 50, 25, 98, 48, 0, 360, white\202;
/* Flood-fill the ellipse. Fill color is red, and will replace the
        black interior of the ellipse. */
gdImageFill\201im, 50, 50, red\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(void)WB 79 Sn( gdImageSetBrush\201gdImagePtr im, gdImagePtr brush\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(A "brush" is an image used to draw wide, shaped strokes in another image. Just
as a paintbrush is not a single point, a brush image need not be
a single pixel. )EM(Any)ES( gd image can be used as a brush, and by
setting the transparent color index of the brush image with
)0 116 1 A(gdImageColorTransparent)116 0 TN TL()Ec /AF f D(,
a brush of any shape can be created. All line-drawing functions,
such as )0 68 1 A(gdImageLine)68 0 TN TL()Ec /AF f D( and
)0 70 1 A(gdImagePolygon)70 0 TN TL()Ec /AF f D(, will use the
current brush if the special "color" )0 131 1 A(gdBrushed)131 0 TN TL()Ec /AF f D( or )0 135 1 A(gdStyledBrushed)135 0 TN TL()Ec /AF f D(
is used when calling them.
)0 P(gdImageSetBrush is used to specify the brush to be used in a
particular image. You can set any image to be the brush.
If the brush image does not have the same color map as the
first image, any colors missing from the first image
will be allocated. If not enough colors can be allocated,
the closest colors already available will be used. This
allows arbitrary PNGs to be used as brush images. It also
means, however, that you should not set a brush unless you
will actually use it; if you set a rapid succession of
different brush images, you can quickly fill your color map,
and the results will not be optimal.
)0 P(You need not take any special action when you are finished
with a brush. As for any other image, if you will not
be using the brush image for any further purpose,
you should call )0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(.
You must not use the color )0 131 1 A(gdBrushed)131 0 TN TL()Ec /AF f D(
if the current brush has been destroyed; you can of
course set a new brush to replace it.
) 21 69 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im, brush;
FILE *in;
int black;
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 100\202;
/* Open the brush PNG. For best results, portions of the
        brush that should be transparent \201ie, not part of the
        brush shape\202 should have the transparent color index. */
in = fopen\201"star.png", "rb"\202;
brush = )0 42 1 A(gdImageCreateFromPng)42 0 TN TL()Ec /AF f D(\201in\202;
/* Background color \201first allocated\202 */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;      
gdImageSetBrush\201im, brush\202;
/* Draw a line from the upper left corner to the lower right corner
        using the brush. */
)0 68 1 A(gdImageLine)68 0 TN TL()Ec /AF f D(\201im, 0, 0, 99, 99, )0 131 1 A(gdBrushed)131 0 TN TL()Ec /AF f D(\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;
/* Destroy the brush image */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201brush\202;)RP(
)DT(void)WB 80 Sn( gdImageSetTile\201gdImagePtr im, gdImagePtr tile\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(A "tile" is an image used to fill an area with  a repeated pattern.
)EM(Any)ES( gd image can be used as a tile, and by
setting the transparent color index of the tile image with
)0 116 1 A(gdImageColorTransparent)116 0 TN TL()Ec /AF f D(,
a tile that allows certain parts of the underlying area to shine
through can be created. All region-filling functions,
such as )0 78 1 A(gdImageFill)78 0 TN TL()Ec /AF f D( and
)0 72 1 A(gdImageFilledPolygon)72 0 TN TL()Ec /AF f D(, will use the
current tile if the special "color" )0 137 1 A(gdTiled)137 0 TN TL()Ec /AF f D( is used when calling them.
)0 P(gdImageSetTile is used to specify the tile to be used in a
particular image. You can set any image to be the tile.
If the tile image does not have the same color map as the
first image, any colors missing from the first image
will be allocated. If not enough colors can be allocated,
the closest colors already available will be used. This
allows arbitrary PNGs to be used as tile images. It also
means, however, that you should not set a tile unless you
will actually use it; if you set a rapid succession of
different tile images, you can quickly fill your color map,
and the results will not be optimal.
)0 P(You need not take any special action when you are finished
with a tile. As for any other image, if you will not
be using the tile image for any further purpose,
you should call )0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(.
You must not use the color )0 131 1 A(gdTiled)131 0 TN TL()Ec /AF f D(
if the current tile has been destroyed; you can of
course set a new tile to replace it.
) 21 69 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im, tile;
FILE *in;
int black;
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 100\202;
/* Open the tile PNG. For best results, portions of the
        tile that should be transparent \201ie, allowing the
        background to shine through\202 should have the transparent
        color index. */
in = fopen\201"star.png", "rb"\202;
tile = )0 42 1 A(gdImageCreateFromPng)42 0 TN TL()Ec /AF f D(\201in\202;
/* Background color \201first allocated\202 */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;      
gdImageSetTile\201im, tile\202;
/* Fill an area using the tile. */
)0 73 1 A(gdImageFilledRectangle)73 0 TN TL()Ec /AF f D(\201im, 25, 25, 75, 75, )0 137 1 A(gdTiled)137 0 TN TL()Ec /AF f D(\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;
/* Destroy the tile image */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201tile\202;)RP(
)DT(void)WB 81 Sn( gdImageSetStyle\201gdImagePtr im, int *style, int styleLength\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(It is often desirable to draw dashed lines, dotted lines, and other
variations on a broken line. gdImageSetStyle can be used to set
any desired series of colors, including a special color that
leaves the background intact, to be repeated during the drawing
of a line.
)0 P(To use gdImageSetStyle, create an array of integers and assign
them the desired series of color values to be repeated.
You can assign the special color value )0 138 1 A(gdTransparent)138 0 TN TL()Ec /AF f D( to indicate that the existing color should
be left unchanged for that particular pixel \201allowing a dashed
line to be attractively drawn over an existing image\202.
)0 P(Then, to draw a line using the style, use the normal
)0 68 1 A(gdImageLine)68 0 TN TL()Ec /AF f D( function with the
special color value )0 133 1 A(gdStyled)133 0 TN TL()Ec /AF f D(.
)0 P(As of )0 150 1 A(version 1.1.1)150 0 TN TL()Ec /AF f D(, the style
array is copied when you set the style, so you need not
be concerned with keeping the array around indefinitely.
This should not break existing code that assumes styles
are not copied.
)0 P(You can also combine styles and brushes to draw the brush
image at intervals instead of in a continuous stroke.
When creating a style for use with a brush, the
style values are interpreted differently: zero \2010\202 indicates
pixels at which the brush should not be drawn, while one \2011\202
indicates pixels at which the brush should be drawn.
To draw a styled, brushed line, you must use the
special color value )0 135 1 A(gdStyledBrushed)135 0 TN TL()Ec /AF f D(. For an example of this feature
in use, see gddemo.c \201provided in the distribution\202.
) 32 71 PR()0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int styleDotted[2], styleDashed[6];
FILE *in;
int black;
int red;
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 100\202;
/* Background color \201first allocated\202 */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;      
red = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 0, 0\202;      
/* Set up dotted style. Leave every other pixel alone. */
styleDotted[0] = red;
styleDotted[1] = gdTransparent;
/* Set up dashed style. Three on, three off. */
styleDashed[0] = red;
styleDashed[1] = red;
styleDashed[2] = red;
styleDashed[3] = gdTransparent;
styleDashed[4] = gdTransparent;
styleDashed[5] = gdTransparent;
/* Set dotted style. Note that we have to specify how many pixels are
        in the style! */
gdImageSetStyle\201im, styleDotted, 2\202;
/* Draw a line from the upper left corner to the lower right corner. */
)0 68 1 A(gdImageLine)68 0 TN TL()Ec /AF f D(\201im, 0, 0, 99, 99, )0 133 1 A(gdStyled)133 0 TN TL()Ec /AF f D(\202;
/* Now the dashed line. */
gdImageSetStyle\201im, styleDashed, 6\202;
)0 68 1 A(gdImageLine)68 0 TN TL()Ec /AF f D(\201im, 0, 99, 0, 99, )0 133 1 A(gdStyled)133 0 TN TL()Ec /AF f D(\202;

/* ... Do something with the image, such as saving it to a file ... */

/* Destroy it */)WR(
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(void)WB 82 Sn( gdImageAlphaBlending\201gdImagePtr im, int blending\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(The )0 82 1 A(gdImageAlphaBlending)82 0 TN TL()Ec /AF f D(
function allows for two different modes of drawing on truecolor
images. In blending mode, the alpha channel component of the color 
supplied to all drawing functions, such as 
)0 67 1 A(gdImageSetPixel)67 0 TN TL()Ec /AF f D(, determines how much of 
the underlying color should be allowed to shine through. As a result, 
gd automatically blends the existing color at that point with the
drawing color, and stores the result in the image. The resulting pixel
is opaque. In non-blending mode, the drawing color is copied literally 
with its alpha channel information, replacing the destination pixel.
Blending mode is not available when drawing on palette images. 
) 23 71 PR()0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int red, blue;
im = )0 38 1 A(gdImageCreateTrueColor)38 0 TN TL()Ec /AF f D(\201100, 100\202;
/* Background color */
red = )0 151 1 A(gdTrueColor)151 0 TN TL()Ec /AF f D(\201255, 0, 0\202;   
gdImageFilledRectangle\201im, 0, 0, 100, 100, red\202;
/* Drawing color. Full transparency would be an alpha channel value
        of 127 \201gd has a 7 bit alpha chnanel\202. 0 is opaque,
        127 is transparent. So cut gdAlphaTransparent in half to get
        50% blending. */
blue = )0 151 1 A(gdTrueColorAlpha)151 0 TN TL()Ec /AF f D(\2010, 0, 255, gdAlphaTransparent / 2\202;     
/* Draw with blending. Result will be 50% red, 50% blue: yellow 
        \201emitted light, remember, not reflected light. What you learned 
        in Kindergarten is wrong here\202. */
gdImageAlphaBlending\201im, 1\202;
)0 73 1 A(gdImageFilledRectangle)73 0 TN TL()Ec /AF f D(\201im, 0, 0, 25, 25, blue\202;
/* Draw without blending. Result will be 50% blue, 50%
        the background color of the image viewer or web browser
        used; results in browsers that don't support
        semi-transparent pixels are unpredictable! */
gdImageAlphaBlending\201im, 0\202;
)0 73 1 A(gdImageFilledRectangle)73 0 TN TL()Ec /AF f D(\201im, 75, 75, 25, 25, blue\202;
/* Write the image to disk, etc. */)RP()LD(
)0 3 46 H(Query)WB 199 Sn()WB 83 Sn( Functions)EA()EH(
)0 DL()DT(int)WB 84 Sn( gdImageAlpha\201gdImagePtr im, int color\202)EA(
)BD(\201MACRO\202)ES(
)DD(gdImageAlpha is a macro which returns the alpha channel component of
the specified color index. Alpha channel values vary between
0 \201gdAlphaOpaque\202, which does not blend at all with the background,
through 127 \201gdAlphaTransparent\202, which allows the background to
shine through 100%. Use this macro rather than accessing the
structure members directly.
int gdImageBlue\201gdImagePtr im, int color\202)EA(
)BD(\201MACRO\202)ES(
)DD(gdImageBlue is a macro which returns the blue component of
the specified color index. Use this macro rather than accessing the
structure members directly.
)DT(int)WB 85 Sn( gdImageGetPixel\201gdImagePtr im, int x, int y\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageGetPixel\201\202 retrieves the color index of a particular
pixel. Always use this function to query pixels;
do not access the pixels of the )0 29 1 A(gdImage)29 0 TN TL()Ec /AF f D( structure
directly.
) 11 72 PR(... inside a function ...
FILE *in;
gdImagePtr im;
int c;
in = fopen\201"mypng.png", "rb"\202;
im = )0 42 1 A(gdImageCreateFromPng)42 0 TN TL()Ec /AF f D(\201in\202;
fclose\201in\202;
c = gdImageGetPixel\201im, gdImageSX\201im\202 / 2, gdImageSY\201im\202 / 2\202;
printf\201"The value of the center pixel is %d; RGB values are %d,%d,%d\200n",
        c, im->red[c], im->green[c], im->blue[c]\202;
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP( 
)DT(int)WB 86 Sn( gdImageBoundsSafe\201gdImagePtr im, int x, int y\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageBoundsSafe returns true \2011\202 if the specified point is within the bounds
of the image, false \2010\202 if not. This function is intended primarily for
use by those who wish to add functions to gd. All of the gd drawing
functions already clip safely to the edges of the image.
) 11 55 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black;
int white;
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 100\202;
if \201gdImageBoundsSafe\201im, 50, 50\202\202 {
        printf\201"50, 50 is within the image bounds\200n"\202;
} else {
        printf\201"50, 50 is outside the image bounds\200n"\202;
}
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(int)WB 87 Sn( gdImageGreen\201gdImagePtr im, int color\202)EA(
)BD(\201MACRO\202)ES(
)DD(gdImageGreen is a macro which returns the green component of
the specified color index. Use this macro rather than accessing the
structure members directly.
)DT(int)WB 88 Sn( gdImageRed\201gdImagePtr im, int color\202)EA(
)BD(\201MACRO\202)ES(
)DD(gdImageRed is a macro which returns the red component of
the specified color index. Use this macro rather than accessing the
structure members directly.
)DT(int)WB 89 Sn( gdImageSX\201gdImagePtr im\202)EA(
)BD(\201MACRO\202)ES(
)DD(gdImageSX is a macro which returns the width of the image
in pixels. Use this macro rather than accessing the
structure members directly.
)DT(int)WB 90 Sn( gdImageSY\201gdImagePtr im\202)EA(
)BD(\201MACRO\202)ES(
)DD(gdImageSY is a macro which returns the height of the image
in pixels. Use this macro rather than accessing the
structure members directly.)LD(
)0 3 47 H(Fonts)WB 200 Sn()WB 91 Sn( and text-handling functions)EA()EH(
)0 DL()DT(void)WB 92 Sn( gdImageChar\201gdImagePtr im, gdFontPtr font, int x, int y,
 int c, int color\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageChar is used to draw single characters on the image.
\201To draw multiple characters, use )0 94 1 A(gdImageString)94 0 TN TL()Ec /AF f D( or )0 95 1 A(gdImageString16)95 0 TN TL()Ec /AF f D(.
See also )0 98 1 A(gdImageStringFT)98 0 TN TL()Ec /AF f D( for a high quality
solution.\202
The second argument is a pointer to a font definition structure; five fonts are
provided with gd, gdFontTiny, gdFontSmall, gdFontMediumBold,
gdFontLarge, and gdFontGiant. You must
include the files "gdfontt.h", "gdfonts.h", "gdfontmb.h",
"gdfontl.h" and "gdfontg.h" respectively
and \201if you are not using a library-based approach\202 link with the
corresponding .c files to use the provided fonts.
The character specified by the fifth
argument is drawn from left to right in the specified
color. \201See )0 93 1 A(gdImageCharUp)93 0 TN TL()Ec /AF f D( for a way
of drawing vertical text.\202 Pixels not
set by a particular character retain their previous color.
) 16 69 PR(#include "gd.h"
#include "gdfontl.h"
... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black;
int white;
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 100\202;
/* Background color \201first allocated\202 */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;      
/* Allocate the color white \201red, green and blue all maximum\202. */
white = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 255, 255\202;        
/* Draw a character. */
gdImageChar\201im, gdFontLarge, 0, 0, 'Q', white\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(void)WB 93 Sn( gdImageCharUp\201gdImagePtr im, gdFontPtr font, int x, int y,
int c, int color\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageCharUp is used to draw single characters on the image,
rotated 90 degrees.
\201To draw multiple characters, use )0 96 1 A(gdImageStringUp)96 0 TN TL()Ec /AF f D( or )0 97 1 A(gdImageStringUp16)97 0 TN TL()Ec /AF f D(.\202 The second argument is a
pointer to a font definition structure; five fonts are
provided with gd, gdFontTiny, gdFontSmall, gdFontMediumBold,
gdFontLarge, and gdFontGiant. You must
include the files "gdfontt.h", "gdfonts.h", "gdfontmb.h",
"gdfontl.h" and "gdfontg.h" respectively
and \201if you are not using a library-based approach\202 link with the
corresponding .c files to use the provided fonts. The character specified by
the fifth argument is drawn
from bottom to top, rotated at a 90-degree angle,  in the specified
color.  \201See )0 92 1 A(gdImageChar)92 0 TN TL()Ec /AF f D( for a way
of drawing horizontal text.\202  Pixels not
set by a particular character retain their previous color.
) 17 72 PR(#include "gd.h"
#include "gdfontl.h"
... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black;
int white;
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 100\202;
/* Background color \201first allocated\202 */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;      
/* Allocate the color white \201red, green and blue all maximum\202. */
white = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 255, 255\202;        
/* Draw a character upwards so it rests against the top of the image. */
gdImageCharUp\201im, gdFontLarge,
        0, gdFontLarge->h, 'Q', white\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(void)WB 94 Sn( gdImageString\201gdImagePtr im, gdFontPtr font, int x, int y,
unsigned char *s, int color\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageString is used to draw multiple characters on the image.
\201To draw single characters, use )0 92 1 A(gdImageChar)92 0 TN TL()Ec /AF f D(.\202 The second argument is a
pointer to a font definition structure; five fonts are
provided with gd, gdFontTiny, gdFontSmall, gdFontMediumBold,
gdFontLarge, and gdFontGiant. You must
include the files "gdfontt.h", "gdfonts.h", "gdfontmb.h",
"gdfontl.h" and "gdfontg.h" respectively
and \201if you are not using a library-based approach\202 link with the
corresponding .c files to use the provided fonts.
The null-terminated C string specified
by the fifth argument is drawn from left to right in the specified
color.  \201See )0 96 1 A(gdImageStringUp)96 0 TN TL()Ec /AF f D( for a way
of drawing vertical text.
See also )0 98 1 A(gdImageStringFT)98 0 TN TL()Ec /AF f D( for a high
quality solution.\202
Pixels not set by a particular character retain their previous color.
) 22 69 PR(#include "gd.h"
#include "gdfontl.h"
#include <string.h>
... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black;
int white;
/* String to draw. */
char *s = "Hello.";
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 100\202;
/* Background color \201first allocated\202 */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;      
/* Allocate the color white \201red, green and blue all maximum\202. */
white = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 255, 255\202;        
/* Draw a centered string. */
gdImageString\201im, gdFontLarge,
        im->w / 2 - \201strlen\201s\202 * gdFontLarge->w / 2\202,
        im->h / 2 - gdFontLarge->h / 2,
        s, white\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(void)WB 95 Sn( gdImageString16\201gdImagePtr im, gdFontPtr font, int x, int y,
unsigned short *s, int color\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageString is used to draw multiple 16-bit characters on the image.
\201To draw single characters, use )0 92 1 A(gdImageChar)92 0 TN TL()Ec /AF f D(.\202 The second argument is a
pointer to a font definition structure; five fonts are
provided with gd, gdFontTiny, gdFontSmall, gdFontMediumBold,
gdFontLarge, and gdFontGiant. You must
include the files "gdfontt.h", "gdfonts.h", "gdfontmb.h",
"gdfontl.h" and "gdfontg.h" respectively
and \201if you are not using a library-based approach\202 link with the
corresponding .c files to use the provided fonts.
The null-terminated string of characters represented as 16-bit unsigned
short integers specified by the fifth argument is drawn from left to right
in the specified
color.  \201See )0 97 1 A(gdImageStringUp16)97 0 TN TL()Ec /AF f D( for a way
of drawing vertical text.\202  Pixels not
set by a particular character retain their previous color.
)0 P(This function was added in gd1.3 to provide a means of rendering
fonts with more than 256 characters for those who have them. A
more frequently used routine is )0 94 1 A(gdImageString)94 0 TN TL()Ec /AF f D(.
)DT(void)WB 96 Sn( gdImageStringUp\201gdImagePtr im, gdFontPtr font, int x, int y,
unsigned char *s, int color\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageStringUp is used to draw multiple characters on the image,
rotated 90 degrees.
\201To draw single characters, use )0 93 1 A(gdImageCharUp)93 0 TN TL()Ec /AF f D(.\202 The second argument is a
pointer to a font definition structure; five fonts are
provided with gd, gdFontTiny, gdFontSmall, gdFontMediumBold,
gdFontLarge, and gdFontGiant. You must
include the files "gdfontt.h", "gdfonts.h", "gdfontmb.h",
"gdfontl.h" and "gdfontg.h" respectively
and \201if you are not using a library-based approach\202 link with the
corresponding .c files to use the provided fonts.The null-terminated C string specified
by the fifth argument is drawn from bottom to top \201rotated
90 degrees\202 in the specified color.  \201See
)0 94 1 A(gdImageString)94 0 TN TL()Ec /AF f D( for a way
of drawing horizontal text.\202  Pixels not
set by a particular character retain their previous color.
) 23 69 PR(#include "gd.h"
#include "gdfontl.h"
#include <string.h>
... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black;
int white;
/* String to draw. */
char *s = "Hello.";
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 100\202;
/* Background color \201first allocated\202 */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;      
/* Allocate the color white \201red, green and blue all maximum\202. */
white = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 255, 255\202;        
/* Draw a centered string going upwards. Axes are reversed,
        and Y axis is decreasing as the string is drawn. */
gdImageStringUp\201im, gdFontLarge,
        im->w / 2 - gdFontLarge->h / 2,
        im->h / 2 + \201strlen\201s\202 * gdFontLarge->w / 2\202,
        s, white\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(void)WB 97 Sn( gdImageStringUp16\201gdImagePtr im, gdFontPtr font, int x, int y,
unsigned short *s, int color\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageString is used to draw multiple 16-bit characters vertically on
the image. \201To draw single characters, use )0 92 1 A(gdImageChar)92 0 TN TL()Ec /AF f D(.\202 The second argument is a
pointer to a font definition structure; five fonts are
provided with gd, gdFontTiny, gdFontSmall, gdFontMediumBold,
gdFontLarge, and gdFontGiant. You must
include the files "gdfontt.h", "gdfonts.h", "gdfontmb.h",
"gdfontl.h" and "gdfontg.h" respectively
and \201if you are not using a library-based approach\202 link with the
corresponding .c files to use the provided fonts.
The null-terminated string of characters represented as 16-bit unsigned
short integers specified by the fifth argument is drawn from bottom to top
in the specified color.
\201See )0 97 1 A(gdImageStringUp16)97 0 TN TL()Ec /AF f D( for a way
of drawing horizontal text.\202  Pixels not
set by a particular character retain their previous color.
)0 P(This function was added in gd1.3 to provide a means of rendering
fonts with more than 256 characters for those who have them. A
more frequently used routine is )0 96 1 A(gdImageStringUp)96 0 TN TL()Ec /AF f D(.
)DT(char)WB 98 Sn( *gdImageStringFT\201gdImagePtr im, int *brect,
 int fg, char *fontname, double ptsize, double angle,
 int x, int y, char *string\202)EA(
)BD(\201FUNCTION\202)ES(
)DD()BD(RECOMMENDED. New in 1.8.4.)ES( gdImageStringFT draws text using the
FreeType 2.x library.
)0 P(gdImageStringFT draws a string of anti-aliased characters on the image using 
the )R5 2 A(FreeType)EA(
library to render user-supplied TrueType fonts. )BD(We do not provide 
TrueType fonts \201.ttf and .ttc files\202. Obtaining them is entirely up to 
you.)ES( The string is anti-aliased, meaning that there should be 
fewer "jaggies" visible. The fontname is the full pathname to a TrueType 
font file, or a font face name if the GDFONTPATH environment variable
or FreeType's DEFAULT_FONTPATH variable have been set intelligently. 
The string may be arbitrarily scaled \201ptsize\202 and rotated \201angle in radians\202.
)0 P(The user-supplied int brect[8] array is filled on return from gdImageStringFT
with the 8 elements representing the 4 corner coordinates of the
bounding rectangle.
)0 PT(
)0 P(The points are relative to the text regardless of the angle, so "upper left"
means in the top left-hand corner seeing the text horizontally.
)0 P(Use a NULL gdImagePtr to get the bounding rectangle without rendering.
This is a relatively cheap operation if followed by a rendering of the same
string, because of the caching of the partial rendering during bounding
rectangle calculation.
)0 P(The string is rendered in the color indicated by the gf color index.
)BD(Use the negative of the desired color index to 
disable anti-aliasing.)ES(
)0 P(The string may contain UTF-8 sequences like: "&#192;"
)0 P(gdImageStringFT will return a null char* on success, or an error
string on failure.
) 40 72 PR(#include "gd.h"
#include <string.h>
... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black;
int white;
int brect[8];
int x, y;
char *err;

char *s = "Hello."; /* String to draw. */
double sz = 40.;
char *f = "/usr/local/share/ttf/Times.ttf";  /* User supplied font */

/* obtain brect so that we can size the image */
err = )0 98 1 A(gdImageStringFT)98 0 TN TL()Ec /AF f D(\201NULL,&brect[0],0,f,sz,0.,0,0,s\202;
if \201err\202 {fprintf\201stderr,err\202; return 1;}

/* create an image big enough for the string plus a little whitespace */
x = brect[2]-brect[6] + 6;
y = brect[3]-brect[7] + 6;
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201x,y\202;

/* Background color \201first allocated\202 */
white = )0 107 1 A(gdImageColorResolve)107 0 TN TL()Ec /AF f D(\201im, 255, 255, 255\202;
black = )0 107 1 A(gdImageColorResolve)107 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;

/* render the string, offset origin to center string*/
/* note that we use top-left coordinate for adjustment
 * since gd origin is in top-left with y increasing downwards. */
x = 3 - brect[6];)WR(
y = 3 - brect[7];
err = )0 98 1 A(gdImageStringFT)98 0 TN TL()Ec /AF f D(\201im,&brect[0],black,f,sz,0.0,x,y,s\202;
if \201err\202 {fprintf\201stderr,err\202; return 1;}

/* Write img to stdout */
)0 56 1 A(gdImagePng)56 0 TN TL()Ec /AF f D(\201im, stdout\202;

/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(char)WB 99 Sn( *gdImageStringTTF\201gdImagePtr im, int *brect,
 int fg, char *fontname, double ptsize, double angle,
 int x, int y, char *string\202)EA(
)BD(\201FUNCTION\202)ES(
)DD()BD(DEPRECATED.)ES( THis function simply invokes
)0 98 1 A(gdImageStringFT)98 0 TN TL()Ec /AF f D( for backwards
compatibility with old code that was written with FreeType 1.x.
/DL>
)0 3 48 H(Color-handling)WB 201 Sn()WB 100 Sn( functions)EA()EH(
)0 DL()DT(int)WB 101 Sn( gdImageColorAllocate\201gdImagePtr im, int r, int g, int b\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageColorAllocate finds the first available color index in
the image specified, sets its RGB values to those requested
\201255 is the maximum for each\202,
and returns the index of the new color table entry, or an RGBA
value in the case of a truecolor image; in either case you can
then use the returned value as a parameter to drawing functions. When
creating a new palette-based image, the first time you invoke this function,
you are setting the background color for that image. 
)0 P(In the event that all )0 132 1 A(gdMaxColors)132 0 TN TL()Ec /AF f D( colors
\201256\202 have already been allocated, gdImageColorAllocate will
return -1 to indicate failure. \201This is not uncommon when
working with existing PNG files that already use 256 colors.\202
Note that gdImageColorAllocate
does not check for existing colors that match your request;
see )0 106 1 A(gdImageColorExact)106 0 TN TL()Ec /AF f D(,
)0 103 1 A(gdImageColorClosest)103 0 TN TL()Ec /AF f D( and
)0 105 1 A(gdImageColorClosestHWB)105 0 TN TL()Ec /AF f D(
for ways to locate existing colors that approximate the
color desired in situations where a new color is not available.
Also see )0 107 1 A(gdImageColorResolve)107 0 TN TL()Ec /AF f D(,
new in gd-1.6.2.
) 14 78 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black;
int red;
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 100\202;
/* Background color \201first allocated\202 */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;      
/* Allocate the color red. */
red = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 0, 0\202;      
/* Draw a dashed line from the upper left corner to the lower right corner. */
gdImageDashedLine\201im, 0, 0, 99, 99, red\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(int)WB 102 Sn( gdImageColorAllocateAlpha\201gdImagePtr im, int r, int g, int b, int a\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageColorAllocateAlpha finds the first available color index in
the image specified, sets its RGBA values to those requested
\201255 is the maximum for red, green and blue, and 127 represents
full transparency for alpha\202,
and returns the index of the new color table entry, or an RGBA
value in the case of a truecolor image; in either case you can
then use the returned value as a parameter to drawing functions. When
creating a new palette-based image, the first time you invoke this function,
you are setting the background color for that image. 
)0 P(In the event that all )0 132 1 A(gdMaxColors)132 0 TN TL()Ec /AF f D( colors
\201256\202 have already been allocated, gdImageColorAllocate will
return -1 to indicate failure. \201This is not uncommon when
working with existing palette-based PNG files that already use 256 colors.\202
Note that gdImageColorAllocateAlpha
does not check for existing colors that match your request;
see )0 152 1 A(gdImageColorExactAlpha)152 0 TN TL()Ec /AF f D( and
)0 104 1 A(gdImageColorClosestAlpha)104 0 TN TL()Ec /AF f D(
for ways to locate existing colors that approximate the
color desired in situations where a new color is not available.
Also see )0 108 1 A(gdImageColorResolveAlpha)108 0 TN TL()Ec /AF f D(.
) 14 78 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black;
int red;
im = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201100, 100\202;
/* Background color \201first allocated\202 */
black = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;      
/* Allocate the color red, 50% transparent. */
red = )0 102 1 A(gdImageColorAllocateAlpha)102 0 TN TL()Ec /AF f D(\201im, 255, 0, 0, 64\202;     
/* Draw a dashed line from the upper left corner to the lower right corner. */
gdImageDashedLine\201im, 0, 0, 99, 99, red\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(int)WB 103 Sn( gdImageColorClosest\201gdImagePtr im, int r, int g, int b\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageColorClosest searches the colors which have been
defined thus far in the image specified and returns the
index of the color with RGB values closest to those of the
request. \201Closeness is determined by Euclidian distance,
which is used to determine the distance in three-dimensional color
space between colors.\202
)0 P(If no colors have yet been allocated in the image,
gdImageColorClosest returns -1.
)0 P(When applied to a truecolor image, this function always
succeeds in returning the desired color.
)0 P(This function is most useful as a backup method for choosing
a drawing color when an image already contains
)0 132 1 A(gdMaxColors)132 0 TN TL()Ec /AF f D( \201256\202 colors and
no more can be allocated. \201This is not uncommon when
working with existing PNG files that already use many colors.\202
See )0 106 1 A(gdImageColorExact)106 0 TN TL()Ec /AF f D(
for a method of locating exact matches only.
) 21 77 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
FILE *in;
int red;
/* Let's suppose that photo.png is a scanned photograph with
        many colors. */
in = fopen\201"photo.png", "rb"\202;
im = )0 42 1 A(gdImageCreateFromPng)42 0 TN TL()Ec /AF f D(\201in\202;
fclose\201in\202;
/* Try to allocate red directly */
red = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 0, 0\202;      
/* If we fail to allocate red... */
if \201red == \201-1\202\202 {
        /* Find the )EM(closest)ES( color instead. */
        red = gdImageColorClosest\201im, 255, 0, 0\202;
}
/* Draw a dashed line from the upper left corner to the lower right corner */
gdImageDashedLine\201im, 0, 0, 99, 99, red\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(int)WB 104 Sn( gdImageColorClosestAlpha\201gdImagePtr im, int r, int g, int b, int a\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageColorClosest searches the colors which have been
defined thus far in the image specified and returns the
index of the color with RGBA values closest to those of the
request. \201Closeness is determined by Euclidian distance,
which is used to determine the distance in four-dimensional color/alpha
space between colors.\202
)0 P(If no colors have yet been allocated in the image,
gdImageColorClosestAlpha returns -1.
)0 P(When applied to a truecolor image, this function always
succeeds in returning the desired color.
)0 P(This function is most useful as a backup method for choosing
a drawing color when a palette-based image already contains
)0 132 1 A(gdMaxColors)132 0 TN TL()Ec /AF f D( \201256\202 colors and
no more can be allocated. \201This is not uncommon when
working with existing palette-based PNG files that already use many colors.\202
See )0 152 1 A(gdImageColorExactAlpha)152 0 TN TL()Ec /AF f D(
for a method of locating exact matches only.
) 21 77 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
FILE *in;
int red;
/* Let's suppose that photo.png is a scanned photograph with
        many colors. */
in = fopen\201"photo.png", "rb"\202;
im = )0 42 1 A(gdImageCreateFromPng)42 0 TN TL()Ec /AF f D(\201in\202;
fclose\201in\202;
/* Try to allocate red, 50% transparent, directly */
red = )0 102 1 A(gdImageColorAllocateAlpha)102 0 TN TL()Ec /AF f D(\201im, 255, 0, 0, 64\202;     
/* If we fail to allocate red... */
if \201red == \201-1\202\202 {
        /* Find the )EM(closest)ES( color instead. */
        red = gdImageColorClosestAlpha\201im, 255, 0, 0, 64\202;
}
/* Draw a dashed line from the upper left corner to the lower right corner */
gdImageDashedLine\201im, 0, 0, 99, 99, red\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(int)WB 105 Sn( gdImageColorClosestHWB\201gdImagePtr im, int r, int g, int b\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageColorClosestHWB searches the colors which have been
defined thus far in the image specified and returns the
index of the color with hue, whiteness and blackness closest to the
requested color. This scheme is typically superior to the 
Euclidian distance scheme used by 
)0 103 1 A(gdImageColorClosest)103 0 TN TL()Ec /AF f D(.
)0 P(If no colors have yet been allocated in the image,
gdImageColorClosestHWB returns -1.
)0 P(When applied to a truecolor image, this function always
succeeds in returning the desired color.
)0 P(This function is most useful as a backup method for choosing
a drawing color when an image already contains
)0 132 1 A(gdMaxColors)132 0 TN TL()Ec /AF f D( \201256\202 colors and
no more can be allocated. \201This is not uncommon when
working with existing PNG files that already use many colors.\202
See )0 106 1 A(gdImageColorExact)106 0 TN TL()Ec /AF f D(
for a method of locating exact matches only.
) 21 77 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
FILE *in;
int red;
/* Let's suppose that photo.png is a scanned photograph with
        many colors. */
in = fopen\201"photo.png", "rb"\202;
im = )0 42 1 A(gdImageCreateFromPng)42 0 TN TL()Ec /AF f D(\201in\202;
fclose\201in\202;
/* Try to allocate red directly */
red = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 0, 0\202;      
/* If we fail to allocate red... */
if \201red == \201-1\202\202 {
        /* Find the )EM(closest)ES( color instead. */
        red = gdImageColorClosestHWB\201im, 255, 0, 0\202;
}
/* Draw a dashed line from the upper left corner to the lower right corner */
gdImageDashedLine\201im, 0, 0, 99, 99, red\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(int)WB 106 Sn( gdImageColorExact\201gdImagePtr im, int r, int g, int b\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageColorExact searches the colors which have been
defined thus far in the image specified and returns the
index of the first color with RGB values which exactly
match those of the request. If no allocated color matches the
request precisely, gdImageColorExact returns -1.
See )0 103 1 A(gdImageColorClosest)103 0 TN TL()Ec /AF f D(
for a way to find the color closest to the color requested.
)0 P(When applied to a truecolor image, this function always
succeeds in returning the desired color.
) 22 77 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int red;
in = fopen\201"photo.png", "rb"\202;
im = )0 42 1 A(gdImageCreateFromPng)42 0 TN TL()Ec /AF f D(\201in\202;
fclose\201in\202;
/* The image may already contain red; if it does, we'll save a slot
        in the color table by using that color. */
/* Try to allocate red directly */
red = gdImageColorExact\201im, 255, 0, 0\202;
/* If red isn't already present... */
if \201red == \201-1\202\202 {
        /* Second best: try to allocate it directly. */
        red = )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(\201im, 255, 0, 0\202;      
        /* Out of colors, so find the )EM(closest)ES( color instead. */
        red = gdImageColorClosest\201im, 255, 0, 0\202;
}
/* Draw a dashed line from the upper left corner to the lower right corner */
gdImageDashedLine\201im, 0, 0, 99, 99, red\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(int)WB 107 Sn( gdImageColorResolve\201gdImagePtr im, int r, int g, int b\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageColorResolve searches the colors which have been
defined thus far in the image specified and returns the
index of the first color with RGB values which exactly
match those of the request. If no allocated color matches the
request precisely, then gdImageColorResolve tries to allocate the
exact color.  If there is no space left in the color table then
gdImageColorResolve returns the closest color \201as in gdImageColorClosest\202.
This function always returns an index of a color.
)0 P(When applied to a truecolor image, this function always
succeeds in returning the desired color.
) 15 77 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int red;
in = fopen\201"photo.png", "rb"\202;
im = )0 42 1 A(gdImageCreateFromPng)42 0 TN TL()Ec /AF f D(\201in\202;
fclose\201in\202;
/* The image may already contain red; if it does, we'll save a slot
        in the color table by using that color. */
/* Get index of red, or color closest to red */
red = gdImageColorResolve\201im, 255, 0, 0\202;
/* Draw a dashed line from the upper left corner to the lower right corner */
gdImageDashedLine\201im, 0, 0, 99, 99, red\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(int)WB 108 Sn( gdImageColorResolveAlpha\201gdImagePtr im, int r, int g, int b, int a\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageColorResolveAlpha searches the colors which have been
defined thus far in the image specified and returns the
index of the first color with RGBA values which exactly
match those of the request. If no allocated color matches the
request precisely, then gdImageColorResolveAlpha tries to allocate the
exact color. If there is no space left in the color table then
gdImageColorResolveAlpha returns the closest color \201as in gdImageColorClosestAlpha\202.
This function always returns an index of a color.
)0 P(When applied to a truecolor image, this function always
succeeds in returning the desired color.
) 15 77 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int red;
in = fopen\201"photo.png", "rb"\202;
im = )0 42 1 A(gdImageCreateFromPng)42 0 TN TL()Ec /AF f D(\201in\202;
fclose\201in\202;
/* The image may already contain red; if it does, we'll save a slot
        in the color table by using that color. */
/* Get index of red, 50% transparent, or the next best thing */
red = gdImageColorResolveAlpha\201im, 255, 0, 0, 64\202;
/* Draw a dashed line from the upper left corner to the lower right corner */
gdImageDashedLine\201im, 0, 0, 99, 99, red\202;
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(int)WB 109 Sn( gdImageColorsTotal\201gdImagePtr im\202)EA(
)BD(\201MACRO\202)ES(
)DD(gdImageColorsTotal is a macro which returns the number of
colors currently allocated in a palette image. For truecolor
images, the result of this call is undefined and should not
be used.
)DT(int)WB 110 Sn( gdImageColorRed\201gdImagePtr im, int c\202)EA(
)BD(\201MACRO\202)ES(
)DD(gdImageColorRed is a macro which returns the red portion
of the specified color in the image. This macro works
for both palette and truecolor images.
)DT(int)WB 111 Sn( gdImageColorGreen\201gdImagePtr im, int c\202)EA(
)BD(\201MACRO\202)ES(
)DD(gdImageColorGreen is a macro which returns the green portion
of the specified color in the image.  This macro works
for both palette and truecolor images.
)DT(int)WB 112 Sn( gdImageColorBlue\201gdImagePtr im, int c\202)EA(
)BD(\201MACRO\202)ES(
)DD(gdImageColorBlue is a macro which returns the green portion
of the specified color in the image.  This macro works
for both palette and truecolor images.
)DT(int)WB 113 Sn( gdImageGetInterlaced\201gdImagePtr im\202)EA(
)BD(\201MACRO\202)ES(
)DD(gdImageGetInterlaced is a macro which returns true \2011\202
if the image is interlaced, false \2010\202 if not.
Use this macro to obtain this information; do not
access the structure directly.
See )0 128 1 A(gdImageInterlace)128 0 TN TL()Ec /AF f D( for
a means of interlacing images.
)DT(int)WB 114 Sn( gdImageGetTransparent\201gdImagePtr im\202)EA(
)BD(\201MACRO\202)ES(
)DD(gdImageGetTransparent is a macro which returns the
current transparent color index in the image.
If there is no transparent color, gdImageGetTransparent
returns -1. Use this macro to obtain this information; do not
access the structure directly.
)DT(void)WB 115 Sn( gdImageColorDeallocate\201gdImagePtr im, int color\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageColorDeallocate marks the specified color as being
available for reuse. It does not attempt to determine whether
the color index is still in use in the image. After a call
to this function, the next call to
)0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(
for the same image will set new RGB values for that
color index, changing the color of any pixels which
have that index as a result. If multiple calls to
gdImageColorDeallocate are made consecutively, the lowest-numbered
index among them will be reused by the next
)0 101 1 A( gdImageColorAllocate)101 0 TN TL()Ec /AF f D( call.
) 19 69 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int red, blue;
in = fopen\201"photo.png", "rb"\202;
im = )0 42 1 A(gdImageCreateFromPng)42 0 TN TL()Ec /AF f D(\201in\202;
fclose\201in\202;
/* Look for red in the color table. */
red = gdImageColorExact\201im, 255, 0, 0\202;
/* If red is present... */
if \201red != \201-1\202\202 {
        /* Deallocate it. */
        gdImageColorDeallocate\201im, red\202;
        /* Allocate blue, reusing slot in table.
                Existing red pixels will change color. */
        blue = gdImageColorAllocate\201im, 0, 0, 255\202;
}
/* ... Do something with the image, such as saving it to a file... */
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(void)WB 116 Sn( gdImageColorTransparent\201gdImagePtr im, int color\202)EA(
)BD(\201FUNCTION\202)ES(
)DD(gdImageColorTransparent sets the transparent color index
for the specified image to the specified index. To indicate
that there should be )EM(no)ES( transparent color, invoke
gdImageColorTransparent with a color index of -1.  Note that
JPEG images do not support transparency, so this setting has no effect
when writing JPEG images.
)0 P(The color index used should be an index
allocated by )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(,
whether explicitly invoked by your code or implicitly
invoked by loading an image.
In order to ensure that your image has a reasonable appearance
when viewed by users who do not have transparent background
capabilities \201or when you are writing a JPEG-format file, which does
not support transparency\202, be sure to give reasonable RGB values to the
color you allocate for use as a transparent color,
)EM(even though it will be transparent on systems
that support PNG transparency)ES(.
) 20 64 PR(... inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im;
int black;
FILE *in, *out;
in = fopen\201"photo.png", "rb"\202;
im = )0 42 1 A(gdImageCreateFromPng)42 0 TN TL()Ec /AF f D(\201in\202;
fclose\201in\202;
/* Look for black in the color table and make it transparent. */
black = )0 106 1 A(gdImageColorExact)106 0 TN TL()Ec /AF f D(\201im, 0, 0, 0\202;
/* If black is present... */
if \201black != \201-1\202\202 {
        /* Make it transparent */
        gdImageColorTransparent\201im, black\202;
}
/* Save the newly-transparent image back to the file */
out = fopen\201"photo.png", "wb"\202;
)0 56 1 A(gdImagePng)56 0 TN TL()Ec /AF f D(\201im, out\202;
fclose\201out\202;
/* Destroy it */
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(void)WB 117 Sn( gdImageTrueColor\201int red, int green, int blue\202)EA(
)BD(\201MACRO\202)ES(
)DD(gdImageTrueColor returns an RGBA color value for use when
drawing on a truecolor image. Red, green, and blue are all
in the range between 0 \201off\202 and 255 \201maximum\202. This macro should 
not be used with palette-based images. If you need to write
code which is compatible with both palette-based and
truecolor images, use )0 107 1 A(gdImageColorResolve)107 0 TN TL()Ec /AF f D(.
)DT(void)WB 118 Sn( gdImageTrueColorAlpha\201int red, int green, int blue, int alpha\202)EA(
)BD(\201MACRO\202)ES(
)DD(gdImageTrueColorAlpha returns an RGBA color value for use when
drawing on a truecolor image with alpha channel transparency. Red, 
green, and blue are all
in the range between 0 \201off\202 and 255 \201maximum\202. Alpha is in the
range between 0 \201opaque\202 and 127 \201fully transparent\202. This macro should 
not be used with palette-based images. If you need to write
code which is compatible with both palette-based and
truecolor images, use )0 108 1 A(gdImageColorResolveAlpha)108 0 TN TL()Ec /AF f D(.)LD(
)0 3 49 H(Copying)WB 202 Sn()WB 119 Sn( and resizing functions)EA()EH(
)0 DL(
)DT(void)WB 120 Sn( gdImageCopy\201gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int w, int h\202
)BD( \201FUNCTION\202)ES(
)DD(gdImageCopy is used to copy a rectangular portion of one image to
another image. \201For a way of stretching or shrinking the image
in the process, see )0 121 1 A(gdImageCopyResized)121 0 TN TL()Ec /AF f D(.\202
)0 P(The )SM(dst)ES( argument is the destination image to which the
region will be copied. The )SM(src)ES( argument is the source
image from which the region is copied. The )SM(dstX)ES(
and )SM(dstY)ES( arguments specify the point in the destination
image to which the region will be copied. The )SM(srcX)ES(
and )SM(srcY)ES( arguments specify the upper left corner
of the region in the source image. The )SM(w)ES(
and )SM(h)ES( arguments specify the width and height
of the region.
)0 P(When you copy a region from one location in an image to another
location in the same image, gdImageCopy will perform as expected
unless the regions overlap, in which case the result is
unpredictable.
)0 P()BD(Important note on copying between images:)ES( since
different images do
not necessarily have the same color tables, pixels are not simply set to the
same color index values to copy them. gdImageCopy will attempt
to find an identical RGB value in the destination image for
each pixel in the copied portion of the source image by
invoking )0 106 1 A(gdImageColorExact)106 0 TN TL()Ec /AF f D(. If
such a value is not found, gdImageCopy will attempt to
allocate colors as needed using )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(. If both of these methods fail,
gdImageCopy will invoke )0 103 1 A(gdImageColorClosest)103 0 TN TL()Ec /AF f D( to find the color in the destination
image which most closely approximates the color of the
pixel being copied.
) 26 60 PR(... Inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im_in;
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im_out;
int x, y;
FILE *in;
FILE *out;
/* Load a small png to tile the larger one with */
in = fopen\201"small.png", "rb"\202;
im_in = )0 42 1 A(gdImageCreateFromPng)42 0 TN TL()Ec /AF f D(\201in\202;
fclose\201in\202;
/* Make the output image four times as large on both axes */
im_out = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201im_in->sx * 4, im_in->sy * 4\202;
/* Now tile the larger image using the smaller one */
for \201y = 0; \201y < 4\202; y++\202 {
        for \201x = 0; \201x < 4\202; x++\202 {
                gdImageCopy\201im_out, im_in,
                        x * im_in->sx, y * im_in->sy,
                        0, 0,
                        im_in->sx, im_in->sy\202;
        }
}
out = fopen\201"tiled.png", "wb"\202;
)0 56 1 A(gdImagePng)56 0 TN TL()Ec /AF f D(\201im_out, out\202;
fclose\201out\202;
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im_in\202;
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im_out\202;)RP(
)DT(void)WB 121 Sn( gdImageCopyResized\201gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int destW, int destH, int srcW, int srcH\202
)BD( \201FUNCTION\202)ES(
)DD(gdImageCopyResized is used to copy a rectangular portion of one image to
another image. The X and Y dimensions of the original region and the
destination region can vary, resulting in stretching or shrinking of
the region as appropriate. \201For a simpler version of this function
which does not deal with resizing, see )0 120 1 A(gdImageCopy)120 0 TN TL()Ec /AF f D(.\202
)0 P(The )SM(dst)ES( argument is the destination image to which the
region will be copied. The )SM(src)ES( argument is the source
image from which the region is copied. The )SM(dstX)ES(
and )SM(dstY)ES( arguments specify the point in the destination
image to which the region will be copied. The )SM(srcX)ES(
and )SM(srcY)ES( arguments specify the upper left corner
of the region in the source image. The )SM(dstW)ES(
and )SM(dstH)ES( arguments specify the width and height
of the destination region. The )SM(srcW)ES(
and )SM(srcH)ES( arguments specify the width and height
of the source region and can differ from the destination size,
allowing a region to be scaled during the copying process.
)0 P(When you copy a region from one location in an image to another
location in the same image, gdImageCopy will perform as expected
unless the regions overlap, in which case the result is
unpredictable. If this presents a problem, create a scratch image
in which to keep intermediate results.
)0 P()BD(Important note on copying between images:)ES( since images
do not necessarily have the same color tables, pixels are not simply set
to the same color index values to copy them. gdImageCopy will attempt
to find an identical RGB value in the destination image for
each pixel in the copied portion of the source image by
invoking )0 106 1 A(gdImageColorExact)106 0 TN TL()Ec /AF f D(. If
such a value is not found, gdImageCopy will attempt to
allocate colors as needed using )0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D(. If both of these methods fail,
gdImageCopy will invoke )0 103 1 A(gdImageColorClosest)103 0 TN TL()Ec /AF f D( to find the color in the destination
image which most closely approximates the color of the
pixel being copied.
) 21 60 PR(... Inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im_in;
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im_out;
int x, y;
FILE *in;
FILE *out;
/* Load a small png to expand in the larger one */
in = fopen\201"small.png", "rb"\202;
im_in = )0 42 1 A(gdImageCreateFromPng)42 0 TN TL()Ec /AF f D(\201in\202;
fclose\201in\202;
/* Make the output image four times as large on both axes */
im_out = )0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D(\201im_in->sx * 4, im_in->sy * 4\202;
/* Now copy the smaller image, but four times larger */
gdImageCopyResized\201im_out, im_in, 0, 0, 0, 0,
        im_out->sx, im_out->sy,
        im_in->sx, im_in->sy\202;  
out = fopen\201"large.png", "wb"\202;
)0 56 1 A(gdImagePng)56 0 TN TL()Ec /AF f D(\201im_out, out\202;
fclose\201out\202;
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im_in\202;
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im_out\202;)RP(
)DT(void)WB 122 Sn( gdImageCopyResampled\201gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int destW, int destH, int srcW, int srcH\202
)BD( \201FUNCTION\202)ES(
)DD(gdImageCopyResampled is used to copy a rectangular portion of one image to
another image, smoothly interpolating pixel values so that, in particular,
reducing the size of an image still retains a great deal of clarity. The 
X and Y dimensions of the original region and the
destination region can vary, resulting in stretching or shrinking of
the region as appropriate. \201For a simpler version of this function
which does not deal with resizing, see )0 120 1 A(gdImageCopy)120 0 TN TL()Ec /AF f D(. For a version which does not interpolate pixel values,
see )0 121 1 A(gdImageCopyResized)121 0 TN TL()Ec /AF f D(.
)0 P(Pixel values are only interpolated if the destination image is a
truecolor image. Otherwise, 
)0 121 1 A(gdImageCopyResized)121 0 TN TL()Ec /AF f D( is 
automatically invoked.
)0 P(The )SM(dst)ES( argument is the destination image to which the
region will be copied. The )SM(src)ES( argument is the source
image from which the region is copied. The )SM(dstX)ES(
and )SM(dstY)ES( arguments specify the point in the destination
image to which the region will be copied. The )SM(srcX)ES(
and )SM(srcY)ES( arguments specify the upper left corner
of the region in the source image. The )SM(dstW)ES(
and )SM(dstH)ES( arguments specify the width and height
of the destination region. The )SM(srcW)ES(
and )SM(srcH)ES( arguments specify the width and height
of the source region and can differ from the destination size,
allowing a region to be scaled during the copying process.
)0 P(When you copy a region from one location in an image to another
location in the same image, gdImageCopy will perform as expected
unless the regions overlap, in which case the result is
unpredictable. If this presents a problem, create a scratch image
in which to keep intermediate results.
)0 P()BD(Important note on copying between images:)ES( since images
do not necessarily have the same color tables, pixels are not simply set
to the same color index values to copy them. If the destination image
is a palette image, gd will use the 
)0 107 1 A(gdImageColorResolve)107 0 TN TL()Ec /AF f D( function to
determine the best color available.
) 22 64 PR(... Inside a function ...
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im_in;
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( im_out;
int x, y;
FILE *in;
FILE *out;
/* Load a large png to shrink in the smaller one */
in = fopen\201"large.png", "rb"\202;
im_in = )0 42 1 A(gdImageCreateFromPng)42 0 TN TL()Ec /AF f D(\201in\202;
fclose\201in\202;
/* Make the output image four times as small on both axes. Use
        a true color image so that we can interpolate colors. */
im_out = )0 38 1 A(gdImageCreateTrueColor)38 0 TN TL()Ec /AF f D(\201im_in->sx / 4, im_in->sy / 4\202;
/* Now copy the large image, but four times smaller */
gdImageCopyResampled\201im_out, im_in, 0, 0, 0, 0,
        im_out->sx, im_out->sy,
        im_in->sx, im_in->sy\202;  
out = fopen\201"large.png", "wb"\202;
)0 56 1 A(gdImagePng)56 0 TN TL()Ec /AF f D(\201im_out, out\202;
fclose\201out\202;
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im_in\202;
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im_out\202;)RP(

)DT(void)WB 123 Sn( gdImageCopyMerge\201gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int w, int h, int pct\202
)BD( \201FUNCTION\202)ES(
)DD(gdImageCopyMerge is almost identical to )0 120 1 A(gdImageCopy)120 0 TN TL()Ec /AF f D(, except that
it 'merges' the two images by an amount specified in the last parameter. If the last
parameter is 100, then it will function identically to gdImageCopy - the source image replaces
the pixels in the destination.
)0 P(If, however, the )BD(pct)ES( parameter is less than 100, then the two images are merged.
With pct = 0, no action is taken.
)0 P(This feature is most useful to 'highlight' sections of an image by merging a solid color with
pct = 50:
) 2 60 PR(... Inside a function ...
gdImageCopyMerge\201im_out, im_in, 100, 200, 0, 0, 30, 50, 50\202;)RP(

)DT(void)WB 124 Sn( gdImageCopyMergeGray\201gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int
 w, int h, int pct\202
)BD( \201FUNCTION\202)ES(
)DD(gdImageCopyMergeGray is almost identical to )0 123 1 A(gdImageCopyMerge)123 0 TN TL()Ec /AF f D(,
except that when merging images it preserves the hue of the source by converting the destination
pixels to grey scale before the copy operation.
) 2 64 PR(... Inside a function ...
gdImageCopyMergeGray\201im_out, im_in, 100, 200, 0, 0, 30, 50, 50\202;)RP(

)DT(void)WB 125 Sn( gdImagePaletteCopy\201gdImagePtr dst, gdImagePtr src\202
)BD( \201FUNCTION\202)ES(
)DD(Copies a palette from one image to another, attempting to match the colors in the target image
to the colors
in the source palette.)LD(
)0 3 50 H(Miscellaneous)WB 203 Sn()WB 126 Sn( Functions)EA()EH(
)0 DL(
)DT(int)WB 127 Sn( gdImageCompare\201gdImagePtr im1, gdImagePtr im2\202
)BD( \201FUNCTION\202)ES(
)DD(gdImageCompare returns a bitmap indicating if the two images are different. The members of the 
bitmap are defined in gd.h, but the most important is GD_CMP_IMAGE, which indicated that the images
will actually appear different when displayed. Other, less important, differences relate to pallette
entries. Any difference in the transparent colour is assumed to make images display differently,
even if the transparent colour is not used.
) 2 35 PR(... Inside a function ...
cmpMask = gdImageCompare\201im1, im2\202;)RP(

)DT(gdImageInterlace\201gdImagePtr)WB 128 Sn( im, int interlace\202)EA( )BD(\201FUNCTION\202)ES(
)DD(gdImageInterlace is used to determine whether an image should be stored
in a linear fashion, in which lines will appear on the display from
first to last, or in an interlaced fashion, in which the image
will "fade in" over several passes. By default, images are not
interlaced.  \201When writing JPEG images, interlacing implies generating
progressive JPEG files, which are represented as a series of scans of
increasing quality.  Noninterlaced gd images result in regular
[sequential] JPEG data streams.\202
)0 P(A nonzero value for the interlace argument turns on interlace;
a zero value turns it off. Note that interlace has no effect
on other functions, and has no meaning unless you save the
image in PNG or JPEG format; the gd and xbm formats do not support
interlace.
)0 P(When a PNG is loaded with
)0 42 1 A(gdImageCreateFromPng)42 0 TN TL()Ec /AF f D( or a JPEG is
loaded with
)0 40 1 A(gdImageCreateFromJpeg)40 0 TN TL()Ec /AF f D(, interlace
will be set according to the setting in the PNG or JPEG file.
)0 P(Note that many PNG and JPEG viewers and web browsers do )EM(not)ES(
support interlace or the incremental display of progressive
JPEGs. However, the interlaced PNG or progressive JPEG should still
display; it will simply appear all at once, just as other images do.
) 12 55 PR(gdImagePtr im;
FILE *out;
/* ... Create or load the image... */

/* Now turn on interlace */
gdImageInterlace\201im, 1\202;
/* And open an output file */
out = fopen\201"test.png", "wb"\202;
/* And save the image  -- could also use )0 54 1 A(gdImageJpeg)54 0 TN TL()Ec /AF f D( */
)0 56 1 A(gdImagePng)56 0 TN TL()Ec /AF f D(\201im, out\202;
fclose\201out\202;
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D(\201im\202;)RP(
)DT(gdFree\201void)WB 129 Sn( *ptr\202)EA( )BD(\201FUNCTION\202)ES(
)DD(gdFree provides a reliable way to free memory allocated by functions
such as )0 57 1 A(gdImagePngPtr)57 0 TN TL()Ec /AF f D( which return
blocks of memory. Use of this function guarantees that the
version of )SM(free\201\202)ES( that is ultimately called will
be intended for use with the version of )SM(malloc\201\202)ES( that
originally allocated the block. )LD(
)0 3 51 H(Constants)WB 204 Sn()WB 130 Sn()EA()EH(
)0 DL()DT(gdBrushed)WB 131 Sn()EA( )BD(\201CONSTANT\202)ES(
)DD(Used in place of a color when invoking a line-drawing
function such as )0 68 1 A(gdImageLine)68 0 TN TL()Ec /AF f D(
or )0 71 1 A(gdImageRectangle)71 0 TN TL()Ec /AF f D(.
When gdBrushed is used as the color, the brush
image set with )0 79 1 A(gdImageSetBrush)79 0 TN TL()Ec /AF f D(
is drawn in place of each pixel of the line \201the brush is
usually larger than one pixel, creating the effect
of a wide paintbrush\202. See also
)0 135 1 A(gdStyledBrushed)135 0 TN TL()Ec /AF f D( for a way
to draw broken lines with a series of distinct copies of an image.
)DT()WB 132 Sn()SM(gdMaxColors)ES()BD(\201CONSTANT\202)ES(
)DD(The constant 256. This is the maximum number of colors in a PNG file
according to the PNG standard, and is also the maximum number of
colors in a gd image.
)DT(gdStyled)WB 133 Sn()EA( )BD(\201CONSTANT\202)ES(
)DD(Used in place of a color when invoking a line-drawing
function such as )0 68 1 A(gdImageLine)68 0 TN TL()Ec /AF f D(
or )0 71 1 A(gdImageRectangle)71 0 TN TL()Ec /AF f D(.
When gdStyled is used as the color, the colors of the pixels are
drawn successively from the style that has been
set with )0 81 1 A(gdImageSetStyle)81 0 TN TL()Ec /AF f D(.
If the color of a pixel is equal to
)0 138 1 A(gdTransparent)138 0 TN TL()Ec /AF f D(, that pixel
is not altered. \201This mechanism is completely unrelated
to the "transparent color" of the image itself; see
)0 116 1 A(gdImageColorTransparent)116 0 TN TL()Ec /AF f D(
gdImageColorTransparent for that mechanism.\202 See also
)WB 134 Sn( gdStyledBrushed)EA(.
)DT(gdStyledBrushed)WB 135 Sn()EA( )BD(\201CONSTANT\202)ES(
)DD(Used in place of a color when invoking a line-drawing
function such as )0 68 1 A(gdImageLine)68 0 TN TL()Ec /AF f D(
or )0 71 1 A(gdImageRectangle)71 0 TN TL()Ec /AF f D(.
When gdStyledBrushed is used as the color, the brush
image set with )0 79 1 A(gdImageSetBrush)79 0 TN TL()Ec /AF f D(
is drawn at each pixel of the line, providing that the
style set with )0 81 1 A(gdImageSetStyle)81 0 TN TL()Ec /AF f D(
contains a nonzero value \201OR gdTransparent, which
does not equal zero but is supported for consistency\202
for the current pixel. \201Pixels are drawn successively from the style as the
line is drawn, returning to the beginning when the
available pixels in the style are exhausted.\202 Note that
this differs from the behavior of )0 133 1 A(gdStyled)133 0 TN TL()Ec /AF f D(,
in which the values in the style are used as actual
pixel colors, except for gdTransparent.
)DT(gdDashSize)WB 136 Sn()EA( )BD(\201CONSTANT\202)ES(
)DD(The length of a dash in a dashed line. Defined to be 4 for
backwards compatibility with programs that use
gdImageDashedLine)WB 69 Sn()EA(. New
programs should use gdImageSetStyle)WB 81 Sn()EA( and call the standard
gdImageLine)WB 68 Sn()EA( function
with the special "color" gdStyled)WB 133 Sn()EA( or gdStyledBrushed)WB 135 Sn()EA(.
)DT(gdTiled)WB 137 Sn()EA( )BD(\201CONSTANT\202)ES(
)DD(Used in place of a normal color in )0 73 1 A(gdImageFilledRectangle)73 0 TN TL()Ec /AF f D(, )0 72 1 A(gdImageFilledPolygon)72 0 TN TL()Ec /AF f D(,
)0 78 1 A(gdImageFill)78 0 TN TL()Ec /AF f D(, and )0 77 1 A(gdImageFillToBorder)77 0 TN TL()Ec /AF f D(. gdTiled selects a pixel from the
tile image set with )0 80 1 A(gdImageSetTile)80 0 TN TL()Ec /AF f D(
in such a way as to ensure that the filled area will be
tiled with copies of the tile image. See the discussions of
)0 78 1 A(gdImageFill)78 0 TN TL()Ec /AF f D( and
)0 77 1 A(gdImageFillToBorder)77 0 TN TL()Ec /AF f D( for special
restrictions regarding those functions.
)DT(gdTransparent)WB 138 Sn()EA( )BD(\201CONSTANT\202)ES(
)DD(Used in place of a normal color in a style to be set with
)0 81 1 A(gdImageSetStyle)81 0 TN TL()Ec /AF f D(.
gdTransparent is )BD(not)ES( the transparent
color index of the image; for that functionality please
see )0 116 1 A(gdImageColorTransparent)116 0 TN TL()Ec /AF f D(.)LD(

)WB 139 Sn()0 3 52 H(About)WB 205 Sn( the additional .gd image file format)EH()EA(
In addition to reading and writing the PNG and JPEG formats and reading the
X Bitmap format, gd has the capability to read and write its
own ".gd" format. This format is )EM(not)ES( intended for
general purpose use and should never be used to distribute
images. It is not a compressed format. Its purpose is solely to
allow very fast loading of images your program needs often in
order to build other images for output. If you are experiencing
performance problems when loading large, fixed PNG images your
program needs to produce its output images, you may wish
to examine the functions )0 45 1 A(gdImageCreateFromGd)45 0 TN TL()Ec /AF f D( and )0 62 1 A(gdImageGd)62 0 TN TL()Ec /AF f D(,
which read and write .gd format images.

)0 P(The program "pngtogd.c" is provided as a simple way of converting
.png files to .gd format. I emphasize again that you will not
need to use this format unless you have a need for high-speed loading
of a few frequently-used images in your program.

)WB 140 Sn()0 3 53 H(About)WB 206 Sn( the .gd2 image file format)EH()EA(
In addition to reading and writing the PNG format and reading the
X Bitmap format, gd has the capability to read and write its
own ".gd2" format. This format is )EM(not)ES( intended for
general purpose use and should never be used to distribute
images. It is a compressed format allowing pseudo-random access
to large image files. Its purpose is solely to
allow very fast loading of )BD(parts)ES( of images
If you are experiencing
performance problems when loading large, fixed PNG or JPEG images your
program needs to produce its output images, you may wish
to examine the functions )0 47 1 A(gdImageCreateFromGd2)47 0 TN TL()Ec /AF f D(, )0 49 1 A(gdImageCreateFromGd2Part)49 0 TN TL()Ec /AF f D( and )0 64 1 A(gdImageGd2)64 0 TN TL()Ec /AF f D(,
which read and write .gd2 format images.

)0 P(The program "pngtogd2.c" is provided as a simple way of converting
.png files to .gd2 format.

)WB 141 Sn()0 3 54 H(About)WB 207 Sn( the gdIOCtx structure)EH()EA(
Version 1.5 of GD added a new style of I/O based on an IOCtx
structure \201the most up-to-date version can be found in gd_io.h\202:
) 13 61 PR(typedef struct gdIOCtx {
        int     \201*getC\202\201struct gdIOCtx*\202;
        int     \201*getBuf\202\201struct gdIOCtx*, void*, int\202;

        void     \201*putC\202\201struct gdIOCtx*, int\202;
        int     \201*putBuf\202\201struct gdIOCtx*, const void*, int\202;

        int     \201*seek\202\201struct gdIOCtx*, const int\202;
        long    \201*tell\202\201struct gdIOCtx*\202;

        void    \201*free\202\201struct gdIOCtx*\202;

} gdIOCtx;)RP(

Most functions that accepted files in previous versions now also have a
counterpart that accepts an I/O context. These functions have a 'Ctx'
suffix.
)0 P(The Ctx routines use the function pointers in the I/O context pointed to
by gdIOCtx to perform all I/O. Examples of how to implement an I/O context
can be found in io_file.c \201which provides a wrapper for file routines\202, and
io_dp.c \201which implements in-memory storage\202.
)0 P(It is not necessary to implement all functions in an I/O context if you know
that it will only be used in limited cirsumstances. At the time of writing
\201Version 1.6.1, July 1999\202, the known requirements are:
)0 P()1 PT(



)WB 142 Sn()0 3 55 H(Please)WB 208 Sn( tell us you're using gd!)EH(
When you contact us and let us know you are using gd,
you help us justify the time spent in maintaining and improving
it. So please let us know. If the results are publicly
visible on the web, a URL is a wonderful thing to receive, but
if it's not a publicly visible project, a simple note is just
as welcome.

)WB 143 Sn()0 3 56 H(If)WB 209 Sn( you have problems)EH()EA(
If you have any difficulties with gd, feel free to contact
the author, )R24 2 A(Thomas Boutell)EA(.
Problems relating to the gd2 format should be addressed to
)0 2 A(Philip Warner)EA(.
)0 P()BD(Be sure to read this manual carefully first.)ES(

)0 3 57 H(Alphabetical)WB 210 Sn()WB 144 Sn( quick index)EA()EH(
)0 131 1 A(gdBrushed)131 0 TN TL()Ec /AF f D( |
)0 136 1 A(gdDashSize)136 0 TN TL()Ec /AF f D( |
)0 31 1 A(gdFont)31 0 TN TL()Ec /AF f D( |
)0 32 1 A(gdFontPtr)32 0 TN TL()Ec /AF f D( |
)0 129 1 A(gdFree)129 0 TN TL()Ec /AF f D( |
)0 29 1 A(gdImage)29 0 TN TL()Ec /AF f D( |
)0 82 1 A(gdImageAlphaBlending)82 0 TN TL()Ec /AF f D( |
)0 74 1 A(gdImageArc)74 0 TN TL()Ec /AF f D( |
)0 84 1 A(gdImageBlue)84 0 TN TL()Ec /AF f D( |
)0 86 1 A(gdImageBoundsSafe)86 0 TN TL()Ec /AF f D( |
)0 92 1 A(gdImageChar)92 0 TN TL()Ec /AF f D( |
)0 93 1 A(gdImageCharUp)93 0 TN TL()Ec /AF f D( |
)0 101 1 A(gdImageColorAllocate)101 0 TN TL()Ec /AF f D( |
)0 102 1 A(gdImageColorAllocateAlpha)102 0 TN TL()Ec /AF f D( |
)0 103 1 A(gdImageColorClosest)103 0 TN TL()Ec /AF f D( |
)0 104 1 A(gdImageColorClosestAlpha)104 0 TN TL()Ec /AF f D( |
)0 115 1 A(gdImageColorDeallocate)115 0 TN TL()Ec /AF f D( |
)0 106 1 A(gdImageColorExact)106 0 TN TL()Ec /AF f D( |
)0 152 1 A(gdImageColorExactAlpha)152 0 TN TL()Ec /AF f D( |
)0 107 1 A(gdImageColorResolve)107 0 TN TL()Ec /AF f D( |
)0 108 1 A(gdImageColorResolveAlpha)108 0 TN TL()Ec /AF f D( |
)0 116 1 A(gdImageColorTransparent)116 0 TN TL()Ec /AF f D( |
)0 120 1 A(gdImageCopy)120 0 TN TL()Ec /AF f D( |
)0 123 1 A(gdImageCopyMerge)123 0 TN TL()Ec /AF f D( |
)0 124 1 A(gdImageMergeGray)124 0 TN TL()Ec /AF f D( |
)0 121 1 A(gdImageCopyResized)121 0 TN TL()Ec /AF f D( |
)0 122 1 A(gdImageCopyResampled)122 0 TN TL()Ec /AF f D( |
)0 38 1 A(gdImageCreate)38 0 TN TL()Ec /AF f D( |
)0 38 1 A(gdImageCreatePalette)38 0 TN TL()Ec /AF f D( |
)0 38 1 A(gdImageCreateTrueColor)38 0 TN TL()Ec /AF f D( |
)0 45 1 A(gdImageCreateFromGd)45 0 TN TL()Ec /AF f D( |
)0 47 1 A(gdImageCreateFromGd2)47 0 TN TL()Ec /AF f D( |
)0 49 1 A(gdImageCreateFromGd2Part)49 0 TN TL()Ec /AF f D( |
)0 40 1 A(gdImageCreateFromJpeg)40 0 TN TL()Ec /AF f D( |
)0 42 1 A(gdImageCreateFromPng)42 0 TN TL()Ec /AF f D( |
)0 44 1 A(gdImageCreateFromPngSource)44 0 TN TL()Ec /AF f D( |
)0 51 1 A(gdImageCreateFromXbm)51 0 TN TL()Ec /AF f D( |
)0 52 1 A(gdImageCreateFromXpm)52 0 TN TL()Ec /AF f D( |
)0 69 1 A(gdImageDashedLine)69 0 TN TL()Ec /AF f D( |
)0 53 1 A(gdImageDestroy)53 0 TN TL()Ec /AF f D( |
)0 78 1 A(gdImageFill)78 0 TN TL()Ec /AF f D( |
)0 75 1 A(gdImageFilledArc)75 0 TN TL()Ec /AF f D( |
)0 76 1 A(gdImageFilledEllipse)76 0 TN TL()Ec /AF f D( |
)0 77 1 A(gdImageFillToBorder)77 0 TN TL()Ec /AF f D( |
)0 73 1 A(gdImageFilledRectangle)73 0 TN TL()Ec /AF f D( |
)0 62 1 A(gdImageGd)62 0 TN TL()Ec /AF f D( |
)0 62 1 A(gdImageGd2)62 0 TN TL()Ec /AF f D( |
)0 113 1 A(gdImageGetInterlaced)113 0 TN TL()Ec /AF f D( |
)0 85 1 A(gdImageGetPixel)85 0 TN TL()Ec /AF f D( |
)0 114 1 A(gdImageGetTransparent)114 0 TN TL()Ec /AF f D( |
)0 87 1 A(gdImageGreen)87 0 TN TL()Ec /AF f D( |
)0 128 1 A(gdImageInterlace)128 0 TN TL()Ec /AF f D( |
)0 54 1 A(gdImageJpeg)54 0 TN TL()Ec /AF f D( |
)0 68 1 A(gdImageLine)68 0 TN TL()Ec /AF f D( |
)0 72 1 A(gdImageFilledPolygon)72 0 TN TL()Ec /AF f D( |
)0 125 1 A(gdImagePaletteCopy)125 0 TN TL()Ec /AF f D( |
)0 56 1 A(gdImagePng)56 0 TN TL()Ec /AF f D( |
)0 58 1 A(gdImagePngToSink)58 0 TN TL()Ec /AF f D( |
)0 70 1 A(gdImagePolygon)70 0 TN TL()Ec /AF f D( |
)0 30 1 A(gdImagePtr)30 0 TN TL()Ec /AF f D( |
)0 59 1 A(gdImageWBMP)59 0 TN TL()Ec /AF f D( |
)0 71 1 A(gdImageRectangle)71 0 TN TL()Ec /AF f D( |
)0 88 1 A(gdImageRed)88 0 TN TL()Ec /AF f D( |
)0 79 1 A(gdImageSetBrush)79 0 TN TL()Ec /AF f D( |
)0 67 1 A(gdImageSetPixel)67 0 TN TL()Ec /AF f D( |
)0 81 1 A(gdImageSetStyle)81 0 TN TL()Ec /AF f D( |
)0 80 1 A(gdImageSetTile)80 0 TN TL()Ec /AF f D( |
)0 94 1 A(gdImageString)94 0 TN TL()Ec /AF f D( |
)0 95 1 A(gdImageString16)95 0 TN TL()Ec /AF f D( |
)0 98 1 A(gdImageStringFT)98 0 TN TL()Ec /AF f D( |
)0 99 1 A(gdImageStringTTF)99 0 TN TL()Ec /AF f D( |
)0 96 1 A(gdImageStringUp)96 0 TN TL()Ec /AF f D( |
)0 96 1 A(gdImageStringUp16)96 0 TN TL()Ec /AF f D( |
)0 59 1 A(gdImageWBMP)59 0 TN TL()Ec /AF f D( |
)0 132 1 A(gdMaxColors)132 0 TN TL()Ec /AF f D( |
)0 33 1 A(gdPoint)33 0 TN TL()Ec /AF f D( |
)0 133 1 A(gdStyled)133 0 TN TL()Ec /AF f D( |
)0 135 1 A(gdStyledBrushed)135 0 TN TL()Ec /AF f D( |
)0 137 1 A(gdTiled)137 0 TN TL()Ec /AF f D( |
)0 138 1 A(gdTransparent)138 0 TN TL()Ec /AF f D(
)0 P()EM()R7 2 A(Boutell.Com, Inc.)EA()ES(
)WB NL /BO 0 D TC /Ba f D Bs /AU f D /UR () D RC ZF
()0 1 -1 H(gd 2.0.1)EH(
              )0 2 -1 H(Table of Contents)EH()WB
ND 1 gt{Ts 3 mul Np 0()0 C()BD(gd 2.0.1)ES()0 1 TN()EA()BN}if
1 NH le{153(1\240\240)1 C(This is gd 2.0.1 BETA.)153 1 TN()EA()BN}if
2 NH le{154(1.1\240\240)2 C(gd 2.0.1)154 1 TN()EA()BN}if
3 NH le{155(1.1.1\240\240)3 C(A graphics library for fast image creation)155 1 TN()EA()BN}if
3 NH le{156(1.1.2\240\240)3 C(Follow this link to the
)R1 2 A(latest version
of this document.)156 1 TN()EA()BN}if
3 NH le{157(1.1.3\240\240)3 C(Table of Contents)157 1 TN()EA()BN}if
3 NH le{158(1.1.4\240\240)3 C(Credits and license terms)158 1 TN()EA()BN}if
3 NH le{159(1.1.5\240\240)3 C(What is gd?)159 1 TN()EA()BN}if
3 NH le{160(1.1.6\240\240)3 C(What if I want to use another programming
language?)160 1 TN()EA()BN}if
4 NH le{161(1.1.6.1\240\240)4 C(Perl)161 1 TN()EA()BN}if
4 NH le{162(1.1.6.2\240\240)4 C(Tcl)162 1 TN()EA()BN}if
4 NH le{163(1.1.6.3\240\240)4 C(Pascal)163 1 TN()EA()BN}if
4 NH le{164(1.1.6.4\240\240)4 C(Haskell)164 1 TN()EA()BN}if
4 NH le{165(1.1.6.5\240\240)4 C(REXX)165 1 TN()EA()BN}if
4 NH le{166(1.1.6.6\240\240)4 C(Any Language)166 1 TN()EA()BN}if
3 NH le{167(1.1.7\240\240)3 C(What's new in version 2.0.1?)167 1 TN()EA()BN}if
3 NH le{168(1.1.8\240\240)3 C(What's new in version 2.0?)168 1 TN()EA()BN}if
3 NH le{169(1.1.9\240\240)3 C(What's new in version 1.8.4?)169 1 TN()EA()BN}if
3 NH le{170(1.1.10\240\240)3 C(What's new in version 1.8.3?)170 1 TN()EA()BN}if
3 NH le{171(1.1.11\240\240)3 C(What's new in version 1.8.2?)171 1 TN()EA()BN}if
3 NH le{172(1.1.12\240\240)3 C(What's new in version 1.8.1?)172 1 TN()EA()BN}if
3 NH le{173(1.1.13\240\240)3 C(What's new in version 1.8?)173 1 TN()EA()BN}if
4 NH le{174(1.1.13.1\240\240)4 C(Additional JPEG Information)174 1 TN()EA()BN}if
3 NH le{175(1.1.14\240\240)3 C(What's new in version 1.7.3?)175 1 TN()EA()BN}if
3 NH le{176(1.1.15\240\240)3 C(What's new in version 1.7.2?)176 1 TN()EA()BN}if
3 NH le{177(1.1.16\240\240)3 C(What's new in version 1.7.1?)177 1 TN()EA()BN}if
3 NH le{178(1.1.17\240\240)3 C(What's new in version 1.7?)178 1 TN()EA()BN}if
3 NH le{179(1.1.18\240\240)3 C(What's new in version 1.6.3?)179 1 TN()EA()BN}if
3 NH le{180(1.1.19\240\240)3 C(What's new in version 1.6.2?)180 1 TN()EA()BN}if
3 NH le{181(1.1.20\240\240)3 C(What's new in version 1.6.1?)181 1 TN()EA()BN}if
3 NH le{182(1.1.21\240\240)3 C(What's new in version 1.6?)182 1 TN()EA()BN}if
3 NH le{183(1.1.22\240\240)3 C(What's new in version 1.5?)183 1 TN()EA()BN}if
3 NH le{184(1.1.23\240\240)3 C(What's new in version 1.4?)184 1 TN()EA()BN}if
3 NH le{185(1.1.24\240\240)3 C(What's new in version 1.3?)185 1 TN()EA()BN}if
3 NH le{186(1.1.25\240\240)3 C(What else do I need to use gd?)186 1 TN()EA()BN}if
3 NH le{187(1.1.26\240\240)3 C(How do I get gd?)187 1 TN()EA()BN}if
4 NH le{188(1.1.26.1\240\240)4 C(By HTTP)188 1 TN()EA()BN}if
4 NH le{189(1.1.26.2\240\240)4 C(By FTP)189 1 TN()EA()BN}if
3 NH le{190(1.1.27\240\240)3 C(How do I build gd?)190 1 TN()EA()BN}if
4 NH le{191(1.1.27.1\240\240)4 C(For Unix)191 1 TN()EA()BN}if
4 NH le{192(1.1.27.2\240\240)4 C(For Windows, Mac, Et Cetera)192 1 TN()EA()BN}if
3 NH le{193(1.1.28\240\240)3 C(gd basics: using gd in your program)193 1 TN()EA()BN}if
3 NH le{194(1.1.29\240\240)3 C(Webpng:)WB 26 Sn( a more powerful gd example)194 1 TN()EA()BN}if
2 NH le{195(1.2\240\240)2 C(Function)WB 27 Sn( and type reference)195 1 TN()EA()BN}if
3 NH le{196(1.2.1\240\240)3 C(Types)WB 28 Sn()196 1 TN()EA()BN}if
3 NH le{197(1.2.2\240\240)3 C(Image)WB 37 Sn( creation, destruction, loading and saving)197 1 TN()EA()BN}if
3 NH le{198(1.2.3\240\240)3 C(Drawing)WB 66 Sn( Functions)198 1 TN()EA()BN}if
3 NH le{199(1.2.4\240\240)3 C(Query)WB 83 Sn( Functions)199 1 TN()EA()BN}if
3 NH le{200(1.2.5\240\240)3 C(Fonts)WB 91 Sn( and text-handling functions)200 1 TN()EA()BN}if
3 NH le{201(1.2.6\240\240)3 C(Color-handling)WB 100 Sn( functions)201 1 TN()EA()BN}if
3 NH le{202(1.2.7\240\240)3 C(Copying)WB 119 Sn( and resizing functions)202 1 TN()EA()BN}if
3 NH le{203(1.2.8\240\240)3 C(Miscellaneous)WB 126 Sn( Functions)203 1 TN()EA()BN}if
3 NH le{204(1.2.9\240\240)3 C(Constants)WB 130 Sn()204 1 TN()EA()BN}if
3 NH le{205(1.2.10\240\240)3 C(About the additional .gd image file format)205 1 TN()EA()BN}if
3 NH le{206(1.2.11\240\240)3 C(About the .gd2 image file format)206 1 TN()EA()BN}if
3 NH le{207(1.2.12\240\240)3 C(About the gdIOCtx structure)207 1 TN()EA()BN}if
3 NH le{208(1.2.13\240\240)3 C(Please tell us you're using gd!)208 1 TN()EA()BN}if
3 NH le{209(1.2.14\240\240)3 C(If you have problems)209 1 TN()EA()BN}if
3 NH le{210(1.2.15\240\240)3 C(Alphabetical)WB 144 Sn( quick index)210 1 TN()EA()BN}if

/TE t D NP TU PM 0 eq and{/Pn () D showpage}if end restore
