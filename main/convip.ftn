*/* RMNLIB - Library of useful routines for C and FORTRAN programming
* * Copyright (C) 1975-2001  Division de Recherche en Prevision Numerique
* *                          Environnement Canada
* *
* * This library is free software; you can redistribute it and/or
* * modify it under the terms of the GNU Lesser General Public
* * License as published by the Free Software Foundation,
* * version 2.1 of the License.
* *
* * This library is distributed in the hope that it will be useful,
* * but WITHOUT ANY WARRANTY; without even the implied warranty of
* * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* * Lesser General Public License for more details.
* *
* * You should have received a copy of the GNU Lesser General Public
* * License along with this library; if not, write to the
* * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
* * Boston, MA 02111-1307, USA.
* */
      SUBROUTINE CONVIP( ip, p, kind, mode, string, flag )
      implicit none
      integer ip, kind, mode
      real p
      character *(*) string 
      logical flag

**********************************************************************
*     Codage/Decodage P de/a IP pour IP1, IP2, IP3
*     necessaire avant de lire/ecrire un enregistrement
*     sur un fichier standard.
*
*     Auteurs: N. Ek et B. Dugas - Mars 1996
*     Revision 001  M. Lepine - juin 1997 convpr devient convip
*     Revision 002  M. Valin  - mai  1998 fichiers std 98
*
*     Input:    MODE = -1, de IP -->  P
*               MODE =  0, forcer conversion pour ip a 31 bits
*                          (default = ip a 15 bits)
*                          (appel d'initialisation)
*               MODE = +1, de P  --> IP
*               FLAG = .true. , ecriture de P avec format dans string
*
*     Input/
*     Ouput:    IP  =   Valeur codee 
*               P    =   Valeur reelle
*               KIND =0, p est en hauteur (m)
*               KIND =1, p est en sigma (0.0 -> 1.0)
*               KIND =2, p est en pression (mb)
*               KIND =3, p est un code arbitraire
*               STRING = valeur de P formattee
**********************************************************************
      real *8 TEN
      parameter (TEN=10.0)
      real *8 limit1, limit2, temp
      integer iexp,  offset, itemp, lstring
      character *128 var_fmt

      logical NEWSTYLE
      real *8 exptab(0:15)
      character *2 kinds(0:3)
      save NEWSTYLE, exptab, kinds

      external qqexit

      data NEWSTYLE /.false./

      data exptab /0.0001D0, 0.001D0, 0.01D0, 0.1D0, 1.0, 10.0, 100.0, 
     %   1000.0, 10000.0, 100000.0, 1000000.0, 10000000.0, 
     %   100000000.0, 1000000000.0, 10000000000.0, 100000000000.0 /

      data kinds / 'm ', 'sg', 'mb', '  '/

      if (mode .eq.0) then
         NEWSTYLE = .true.
         return
      endif
      if(flag)lstring=len(string)
*
      if (mode.gt.0) then
*
*        Conversion P a IP
*
       if ( kind.lt.0 .or. kind.gt.3) then
            write(6,6003) kind
            call qqexit(3)
       endif
       if(NEWSTYLE)then
         iexp = 4
         if ( P .ge. 0) then
            temp = p
            limit1 = 1000000.0
            limit2 = 100000.0
            offset = 0
         else
            temp = -p
            limit1 = 48000.0
            limit2 = 4800.0
            offset = 1000000
         endif
100      if ( iexp .gt. 0 .and. iexp .lt. 15 ) then
            ip = temp
            if ( ip .eq. temp .and. temp .le. limit1)
     %         goto 101
            if (temp .gt. limit1 ) then
               temp = temp / TEN
               iexp = iexp -1
            else if ( temp .le. limit2 ) then
               temp = temp * TEN
               iexp = iexp + 1
            else
               goto 101
            endif
         goto 100
         endif
101      continue
         if ( temp .gt. limit1 ) then
            ip = -1
         else
            ip = offset + temp + .5
         endif
         ip = ior (ip,ishft(iexp,20))
         ip = ior (ip,ishft(iand(15,kind),24))
       else

         if (kind.eq.1) then

*           ... de sigma ...

            if ( p .lt. 0.0 .or. p .gt. 1.0 ) then
               write(6,6001) p
               call qqexit(1)
            endif

            ip = nint( p * 10000. ) + 2000

         elseif (kind.eq.2) then

*           ... ou de pression.

            if ( p .lt. 0.0 .or. p .gt. 1200. ) then
               write(6,6002) p
               call qqexit(2)
            endif

            if (0.999999e+1 .le. p .and. p .le. 1200. ) then
               ip = nint ( p )
            elseif ( p .lt. 0.999999e+1 ) then
               if( p .ge. 0.999999e0 ) then
                  ip = 1800 + nint(20.*p)
               elseif ( p .ge. 0.999999e-1 ) then
                  ip = 1600 + nint(200.*p)
               elseif ( p .ge. 0.999999e-2 ) then
                  ip = 1400 + nint(2000.*p)
               elseif ( p .ge. 0.999999e-3 ) then
                  ip = 1200 + nint(20000.*p)
               else
                  ip = 0
               endif
            endif

         elseif (kind.eq.0) then

*           ... ou de hauteur

            ip = max(12001,min(32000,nint(p/5.0 + 12001)))

         else

*           Valeur illegale de kind.

            write(6,6003) kind
            call qqexit(3)

         endif

       endif

      elseif (mode.lt.0) then

*        Conversion de ip ...

         if ( ip .gt. 32767 ) then

*           nouveau codage

            kind = iand(15,ishft(ip,-24))
            if(kind.ge.3)kind=3
            iexp = iand (15,ishft(ip,-20))
            itemp = iand (1048575, ip)
            p = itemp / exptab(iexp)

            if (flag) then
               if(p .eq. int(p) .and. p.lt.1000000.) then
                  write(var_fmt,'(i6,1x,a2)')int(p),kinds(kind)
               elseif (p.gt. 1000000.) then
                  write(var_fmt,'(e9.4,1x,a2)')p,kinds(kind)
               elseif (p.gt. 100.) then
                  write(var_fmt,'(f6.2,1x,a2)')p,kinds(kind)
               elseif (p.gt. 10.) then
                  write(var_fmt,'(f6.3,1x,a2)')p,kinds(kind)
               elseif (p.gt. 1.) then
                  write(var_fmt,'(f6.4,1x,a2)')p,kinds(kind)
               elseif (p.ge. 0.001) then
                  write(var_fmt,'(f6.5,1x,a2)')p,kinds(kind)
               else
                  write(var_fmt,'(e9.4,1x,a2)')p,kinds(kind)
               endif
               string=var_fmt
            endif

         elseif ( ip .gt. 12000 .and. ip .le. 32000) then

*           ... a hauteur ...

            kind = 0
            p = 5 * ( ip -12001)
            if (flag) write(string,'(i6,1x,a1)') int(p),'m'


         elseif ( ip .ge. 2000 .and. ip .le. 12000 ) then

*           ... a sigma ...

            kind = 1
            p = float (ip - 2000) / 10000.
            if (flag) write(string,'(f6.4,1x,a2)') p,'sg'

         elseif ( ip .ge. 0 .and. ip .lt. 2000 ) then

*           ... ou a pression.
     
            kind = 2
            if ( 0 .le. ip .and. ip .le. 1200 ) then
               p = float(ip)
               if (flag) write(string,'(i6,1x,a2)') int(p),'mb'
            elseif ( ip .lt. 1400 ) then
                  p = float(ip-1200) / 20000.
                  if (flag) write(string,'(f6.5,1x,a2)') p,'mb'
            elseif ( ip .lt. 1600) then
                  p = float(ip-1400) / 2000.
                  if (flag) write(string,'(f6.4,1x,a2)') p,'mb'
            elseif ( ip .lt. 1800) then
                  p = float(ip-1600) / 200.
                  if (flag) write(string,'(f6.3,1x,a2)') p,'mb'
            elseif  ( ip .lt. 2000) then
                  p = float(ip-1800) / 20.
                  if (flag) write(string,'(f6.2,1x,a2)') p,'mb'
            endif

         elseif ( ip .eq. 32767) then
            kind = 3
            p = ip
            if (flag) write(string,'(i6,3x)') int(p)

         else

*           Valeur illegale de ip.

            write(6,6004) ip
            call qqexit(4)

         endif

      endif
      
      return

**********************************************************************
 6001 format(' Dans convip: sigma initial =',e10.5)
 6002 format(' Dans convip: pression initiale =',e10.5)
 6003 format(' Dans convip: kind initial =',I10)
 6004 format(' Dans convip: ip initial =',I10)

      end
      
      subroutine igapg(grtyp,pg1,pg2,pg3,pg4,ig1,ig2,ig3,ig4)
      implicit none
      character *1 grtyp
      character *(*) pg1,pg2,pg3,pg4
      integer ig1,ig2,ig3,ig4
*
      real xg1,xg2,xg3,xg4
      external cigaxg
*
      if ((grtyp .eq. 'Y') .or. (grtyp .eq. 'Z')) then
         write(pg1,'(i6)') ig1
         write(pg2,'(i6)') ig2
         write(pg3,'(i7)') ig3
         write(pg4,'(i7)') ig4
         return
      else if ((grtyp .eq. 'A') .or. (grtyp .eq. 'B') .or.
     %         (grtyp .eq. 'G') .or. (grtyp .eq. 'N') .or.
     %         (grtyp .eq. 'S')) then
         call cigaxg(grtyp,xg1,xg2,xg3,xg4,ig1,ig2,ig3,ig4)
      else
         write(pg1,'(i6)') ig1
         write(pg2,'(i6)') ig2
         write(pg3,'(i7)') ig3
         write(pg4,'(i7)') ig4
         return
      endif
      if ((grtyp .eq. 'N') .or. (grtyp .eq. 'S')) then
         write(pg1,'(f6.1)') xg1
         write(pg2,'(f6.1)') xg2
         write(pg3,'(f5.1,a2)') (xg3/1000.), 'Km'
         write(pg4,'(f7.3)') xg4
      else if ((grtyp .eq. 'A') .or. (grtyp .eq. 'B') .or.
     %         (grtyp .eq. 'G')) then
         write(pg1,'(i6)') int(xg1)
         write(pg2,'(i6)') int(xg2)
         write(pg3,'(i7)') int(xg3)
         write(pg4,'(i7)') int(xg4)
      else
         write(pg1,'(f6.2)') xg1
         write(pg2,'(f6.2)') xg2
         write(pg3,'(f7.3)') xg3
         write(pg4,'(f7.3)') xg4
      endif
      return
      end





