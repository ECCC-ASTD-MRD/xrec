*/* RMNLIB - Library of useful routines for C and FORTRAN programming
* * Copyright (C) 1975-2001  Division de Recherche en Prevision Numerique
* *                          Environnement Canada
* *
* * This library is free software; you can redistribute it and/or
* * modify it under the terms of the GNU Lesser General Public
* * License as published by the Free Software Foundation,
* * version 2.1 of the License.
* *
* * This library is distributed in the hope that it will be useful,
* * but WITHOUT ANY WARRANTY; without even the implied warranty of
* * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* * Lesser General Public License for more details.
* *
* * You should have received a copy of the GNU Lesser General Public
* * License along with this library; if not, write to the
* * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
* * Boston, MA 02111-1307, USA.
* */
      SUBROUTINE XDASHD (IPAT,NNC,JCRT,JSIZE)
      CHARACTER *(*) IPAT
*
* **********************************************************************
*
* MACHINE DEPENDENT CONSTANTS
*     NBCHR  = NUMBER OF BITS PER CHARACTER.
*     NBWD   = NUMBER OF BITS PER WORD.
*     NCHRWD = NUMBER OF CHARACTERS PER WORD.
*
* **********************************************************************
*
      PARAMETER (NBCHR=8, NBWD=8, NCHRWD=NBWD/NBCHR)
      INTEGER IGAP, ISOL, IBLK
      data igap/'"   '/,isol/'$   '/,iblk/'    '/
*     DATA IGAP /4H"   /, ISOL /4H$   /, IBLK /4H    /
*    
#include "xdashd1.cdk"
#include "xdashd2.cdk"
#include "xdashd3.cdk"
*
#include "xdsave2.cdk"
*
* IFSTFL AND IVCTFG ARE FLAGS USED IN CFVLD.
*
*
      EQUIVALENCE     (ISIZE,SIZE)
*
#if !defined (CRAY) 
      INTEGER SHIFTL
#endif
*
      DATA IP/155*0/
      DATA IPFLAG/155*0/
*
* PSEUDO BLOCK DATA
*
      DATA IFSTFL /1/
      DATA IVCTFG /1/
*
* ISL IS A FLAG FOR AN ALL SOLID PATTERN (+1) OR AN ALL GAP PATTERN (-1)
*
      DATA ISL /1/
*
* MNCSTR IS THE MAXIMUM NUMBER OF CHARACTERS ALLOWED IN A HOLLERITH
* STRING PASSED TO DASHD.
*
      DATA MNCSTR /15/
#if defined (SUN) 
      SHIFTL(J,N) = lshift(J,N)
#endif
#if defined (SGI) || defined (i386) || defined (Alpha) || defined (Darwin_OSX_PPC) || defined (Amd64) || defined (AIX)
      SHIFTL(J,N) = ishft(J,N)
#endif
#if defined (HP) 
      SHIFTL(J,N) = ishft(J,N)
#endif
*
      nc = len(ipat)
      MNCST1 = MNCSTR + 1
*
*  END OF PSEUDO BLOCK DATA
*
*
* COMPUTE USEFUL CONSTANTS FROM NBWD AND NBCHR.
*     NWDSTR - NUMBER OF WORDS IN A MAXIMUM LENGTH STRING.
*
      NWDSTR = (MNCSTR + NCHRWD)/NCHRWD
*
*
* NCHRTS - NUMBER OF CHARS IN THIS HOLLERITH STRING.
* L - NUMBER OF WORDS IN THE FINAL PATTERN, POINTER TO IP ARRAY.
* ISL - FLAG FOR ALL SOLID PATTERN (1) OR ALL GAP PATTERN (-1).
* INTEN - PLOTTER INTENSITY.
*
   10 CONTINUE
      NCHRTS = 0
      L = 0
      ISL = 0
*
* SET HARDWARE DASH LINE ROUTINE TO ALL SOLID PATTERN.
*
*
* RETRIEVE THE RESOLUTION AS SET BY THE USER.
*
C     CALL XGETSI (LXSAVE,LYSAVE)
*
* IADJUS - TO ADJUST NUMBERS TO THE GIVEN RESOLUTION.
*
C     IADJUS =  SHIFT(1,15-LXSAVE)
      IADJUS =  1
*
* TEST WHICH METHOD OF DEFINING THE PATTERN WAS USED.
*
* COPY ARGUMENTS TO LOCAL VARIABLES.
* COMPUTE THE CHARACTER WIDTH IN CRT UNITS.
*
      ICRT = JCRT*IADJUS
      ISIZE = JSIZE
      IF (ISIZE .GT. 1024) GO TO 20
      CHARW = ISIZE*IADJUS
      IF (ISIZE .GT. 3) GO TO 30
      CHARW = 8. + FLOAT(ISIZE)*4.
      IF (ISIZE .EQ. 3) CHARW = 24.
      GO TO 30
20    CHARW = SIZE*8.0*FLOAT(IADJUS)
*
   30 CONTINUE
      IF (ICRT .LT. 1) GO TO 230
      MODE = 2
*
* START MAIN LOOP  (ONLY USED WHEN IPAT IS A CHAR STRING, NOT AN OCTAL N
*
* THIS LOOP GENERATES THE IP ARRAY (NEEDED BY CURVED,VECTD,ETC.) FROM TH
* IPAT CHAR STRING.EACH ITERATION OF THE INNER LOOP ("DO 160...") PROCES
* ONE CHAR OF IPAT. THERE ARE TWO TYPES OF IP ARRAY ENTRIES PRODUCED --
*   1)ONE WORD LONG, INTEGER, GIVES THE LENGTH IN CRT UNITS OF A GAP
*      SEGMENT (CORRESPONDING IPFLAG ELEMENT SET TO -1) OR A SOLID
*      SEGMENT (CORRESP. IPFLAG ELEMENT SET TO 1).
*   2)NWDSTR WORDS LONG, CONTAINS HOLLERITH STRING OF LENGTH LE MNCSTR,L
*      JUSTIFIED, ZERO FILLED, CHAR COUNT IN CHAR NUMBER MNCSTR+1.
*      (CORRESPONDING IPFLAG ELEMENTS SET TO 0).
* THE 160 LOOP HANDLES 5 CASES -- 1) CONTINUE TYPE 2 ENTRY
* (60-80),2)START TYPE 2 ENTRY(80-90),3)END TYPE 2 ENTRY - START TYPE 1
* ENTRY(90-160),4)START TYPE 1 ENTRY OR SWITCH TYPE 1 ENTRY-GAP TO SOLID
* SOLID TO GAP (140-160) , 5) CONTINUE TYPE 1 ENTRY (150-160).
*
      DO 160 J=1,NC
*
* GET NEXT CHAR INTO ICR, RIGHT JUSTIFIED ZERO FILLED.
*
            READ(IPAT(J:J),'(A1)') ICR
*
* MODE SPECIFIES WHAT THE LAST CHAR PROCESSED WAS, AS FOLLOWS.
*    LAST ICR WAS $ (SOLID),      MODE IS 8
*    LAST ICR WAS " (GAP),        MODE IS 2
*    LAST ICR WAS HOLLERITH CHAR, MODE IS 5
* NMODE SPECIFIES WHAT THE CURRENT CHAR TO BE PROCESSED IS.  ICR = $, NM
* IS 1. ICR = ", NMODE IS -1. ICR = HOLLERITH CHAR, NMODE = 0.
* TOGETHER, MODE AND NMODE SPECIFY WHICH CASE THE 160 LOOP CURRENTLY HAS
* PROCESS.
*
            NMODE = 0
            IF (ICR .EQ. IBLK) GO TO 160
            IF (ICR .EQ. IGAP) NMODE = -1
            IF (ICR .EQ. ISOL) NMODE = 1
            IF (L.EQ.0 .AND. NMODE.EQ.-1) MODE = 8
*
* NGO DETERMINES WHERE TO BRANCH BASED ON CASE TO BE PROCESSED.
* COMPUTE MODE FOR NEXT ITERATION.
*
            NGO = NMODE+MODE+ABS(IGP)
            MODE = NMODE*3+5
            GO TO (150,80,140,90,60,90,140,80,150,150,
     1          80,140,90,60,90,140,80,150,150,80,140,
     2          90,60,90,140,80,150),NGO
*
* NCHRTW - NUMBER OF CHARS IN THIS WORD OF A HOLLERITH STRING.
* LGBSTR - L FOR THE GAP BEFORE A STRING. PTR TO LAST WORD BEFORE A TYPE
*   ENTRY IN IP ARRAY.
* LEOSTR - L AT THE END OF A STRING. PTR TO LAST WORD OF A TYPE 2 ENTRY.
*
*
* CHAR TO CHAR
*
* CASE 1) - CONTINUE HOLLERITH STRING ENTRY.  ICR IS HOLLERITH CHAR.
* TEST - MORE CHARS ALLOWED. NO, GO TO 160. YES, TEST - IS THIS WORD FUL
* YES, GET NEXT WORD, ADD CHAR, BUMP COUNTERS. NO, ADD CHAR TO THIS WORD
* BUMP COUNTERS.
*
   60      IF (NCHRTS .EQ. MNCSTR) GO TO 160
           IF (NCHRTW .LT. NCHRWD) GO TO 70
           L = MIN0(L+1,NP)
           IPFLAG(L) = 0
           NCHRTW = 1
           NCHRTS = NCHRTS + 1
C          CALL XSETCHR(IP(LGBPL1),MNCST1,NCHRTS,ICR)
           IP(LGBPL1+NCHRTS-1) = ICR
           GO TO 160
   70      CONTINUE
           NCHRTW = NCHRTW + 1
           NCHRTS = NCHRTS + 1
C          CALL XSETCHR(IP(LGBPL1),MNCST1,NCHRTS,ICR)
           IP(LGBPL1+NCHRTS-1) = ICR
           GO TO 160
*
* BLANK OR SOLID TO CHAR
*
* CASE 2) - START HOLLERITH STRING ENTRY.  ICR IS HOLLERITH CHAR.
* SAVE WORD BEFORE STRING TO BE FILLED IN WITH GAP SEGMENT. LGBSTR POINT
* THIS WORD. GET NEXT WORD, ADD CHAR, INITIALIZE COUNTERS.
*
   80      LGBSTR = MIN0(L+1,NP)
           L = MIN0(LGBSTR+1,NP)
           LGBPL1 = L
           IPFLAG(L) = 0
C          CALL XSETCHR (IP(LGBPL1),MNCST1,1,ICR)
           IP(LGBPL1) = ICR
           NCHRTS = 1
           NCHRTW = 1
           GO TO 160
*
* CHAR TO LINE
*
* CASE 3) - END HOLLERITH STRING ENTRY.  ICR IS A $ OR ".
* SET LEOSTR PTR. IF THIS STRING IS TOO SHORT TO FILL NWDSTR WORDS,
* ZERO OUT EXTRA WORDS.  ADVANCE L TO POINT TO LAST WORD. FILL IN
* CHAR COUNT AND GAP SEGMENT LENGTH.
*
   90      CONTINUE
           LEOSTR = LGBSTR + NWDSTR
           IF (L .EQ. LEOSTR) GO TO 130
           L = L + 1
           DO 120 LL = L,LEOSTR
           IP(LL) = 0
           IPFLAG(LL) = 0
  120      CONTINUE
           L = LEOSTR
C 130      CALL XSETCHR (IP(LGBPL1),MNCST1,MNCST1,NCHRTS)
  130      IP(LGBPL1+MNCST1-1) = NCHRTS
           IP(LGBSTR) = CHARW*(FLOAT(NCHRTS) + .5)
           IF(IGP.EQ.18) IP(LGBSTR)=CHARW*FLOAT(NCHRTS)
           IPFLAG(LGBSTR) = -1
           IF(ABS(IGP).NE.9) IPFLAG(LGBSTR)=1
*
* BLANK TO SOLID OR SOLID TO BLANK
*
* CASE 4) - START TYPE 1 ENTRY,ETC.   ICR IS A $ OR ".
* GET NEXT WORD, ZERO IT OUT.
*
  140       L = MIN0(L+1,NP)
            IP(L) = 0
*
* ADD TO A BLANK OR SOLID LINE
*
* CASE 5) - CONTINUE TYPE 1 ENTRY.  ICR IS A $ OR ".
* ADD ICRT UNITS TO THE PLOTTER ADDRESS UNITS IN IP(L).
* NMODE INDICATES IF IT IS A GAP OR A SOLID.
*
  150       IP(L) = IP(L) + ICRT
            IPFLAG(L) = NMODE
  160    CONTINUE
*
* IF LAST ICR PROCESSED WAS A HOLLERITH CHAR, MUST END HOLLERITH STRING
* ENTRY. ZERO FILL EXTRA WORDS, FILL
* IN CHAR COUNT AND GAP LENGTH, ETC. (AS ABOVE)
*
      IF (NGO .NE. 11 .AND. NGO.NE.14 .AND. NGO.NE.17 .AND. NGO.NE.2
     1                .AND. NGO.NE.5 .AND. NGO.NE.8 ) GO TO 220
      LEOSTR = LGBSTR + NWDSTR
      IF (L .EQ. LEOSTR) GO TO 210
      L = L + 1
      DO 200 LL = L,LEOSTR
      IP(LL) = 0
      IPFLAG(LL) = 0
  200 CONTINUE
      L = LEOSTR
C 210 CALL XSETCHR (IP(LGBPL1),MNCST1,MNCST1,NCHRTS)
  210 IP(LGBPL1+MNCST1-1) = NCHRTS
      IP(LGBSTR) = CHARW*(FLOAT(NCHRTS)+.5)
      IF(IGP.EQ.18) IP(LGBSTR)=CHARW*FLOAT(NCHRTS)
      IPFLAG(LGBSTR) = -1
      IF(ABS(IGP).NE.9) IPFLAG(LGBSTR) = 1
*
* IF IP ARRAY HAS ONLY ONE TYPE 1 ENTRY, SET ISL FLAG.
*
  220 IF (L .GT. 1) RETURN
      IBIG =  SHIFTL(1,MAX0(LXSAVE,LYSAVE))
      IF (IP(L) .GE. IBIG) GO TO 230
      IF (IPFLAG(L)) 240,240,230
  230 ISL = 1
      RETURN
  240 ISL = -1
      RETURN
      END
